function ResourceGroupVersion(e, t, n) {
return this.resource = e, this.group = t, this.version = n, this;
}

!function() {
"use strict";
if (Logger.setLevel(Logger.INFO), window.LogBuffer = 100, "localStorage" in window) {
"logLevel" in window.localStorage || (window.localStorage.logLevel = JSON.stringify(Logger.INFO));
var e = Logger.DEBUG;
try {
e = JSON.parse(window.localStorage.logLevel);
} catch (e) {
console.error("Failed to parse log level setting: ", e);
}
if (Logger.setLevel(e), "logBuffer" in window.localStorage) {
var t = window.localStorage.logBuffer;
window.LogBuffer = parseInt(t, 10);
} else window.localStorage.logBuffer = window.LogBuffer;
}
}();

var pluginLoader = function(e) {
"use strict";
function t(e, t) {
angular.isArray(t) || (t = [ t ]);
var n = [];
return t.forEach(function(t) {
e.forEach(function(e) {
t === e && n.push(e);
});
}), n;
}
var n = Logger, r = document.documentElement;
return e.log = n, e.modules = [], e.tasks = [], e.setBootstrapElement = function(e) {
n.debug("Setting bootstrap element to: ", e), r = e;
}, e.getBootstrapElement = function() {
return r;
}, e.registerPreBootstrapTask = function(t, r) {
angular.isFunction(t) && (n.debug("Adding legacy task"), t = {
task: t
}), t.name || (t.name = "unnamed-task-" + (e.tasks.length + 1)), t.depends && !angular.isArray(t.depends) && "*" !== t.depends && (t.depends = [ t.depends ]), r ? e.tasks.unshift(t) : e.tasks.push(t);
}, e.addModule = function(t) {
n.debug("Adding module: " + t), e.modules.push(t);
}, e.getModules = function() {
return e.modules;
}, e.loaderCallback = null, e.setLoaderCallback = function(t) {
e.loaderCallback = t;
}, e.loadPlugins = function(r) {
var o = e.loaderCallback, i = {}, a = function() {
var n = [], o = [], i = {
name: "Bootstrap",
depends: "*",
runs: 0,
task: function(t) {
function r() {
o.forEach(function(t) {
e.log.info("  name: " + t.name + " depends: ", t.depends);
});
}
o.length > 0 && (e.log.info("tasks yet to run: "), r(), i.runs = i.runs + 1, e.log.info("Task list restarted : ", i.runs, " times"), 5 === i.runs ? (e.log.info("Orphaned tasks: "), r(), o.length = 0) : o.push(i)), e.log.debug("Executed tasks: ", n), t();
}
};
e.registerPreBootstrapTask(i);
var a = function() {
var i = null, s = [];
for (0 === e.tasks.length && (i = o.shift()); !i && o.length > 0; ) {
var c = o.shift();
"*" === c.depends ? e.tasks.length > 0 ? s.push(c) : i = c : (l = t(n, c.depends)).length === c.depends.length ? i = c : s.push(c);
}
if (s.length > 0 && s.forEach(function(e) {
o.push(e);
}), i || (i = e.tasks.shift()), i && i.depends && e.tasks.length > 0) if (e.log.debug("Task '" + i.name + "' has dependencies: ", i.depends), "*" === i.depends) {
if (e.tasks.length > 0) return e.log.debug("Task '" + i.name + "' wants to run after all other tasks, deferring"), o.push(i), void a();
} else {
var l = t(n, i.depends);
if (l.length != i.depends.length) return e.log.debug("Deferring task: '" + i.name + "'"), o.push(i), void a();
}
if (i) {
e.log.debug("Executing task: '" + i.name + "'");
var u = function() {
u.notFired && (u.notFired = !1, n.push(i.name), setTimeout(a, 1));
};
u.notFired = !0, i.task(u);
} else e.log.debug("All tasks executed"), setTimeout(r, 1);
};
setTimeout(a, 1);
};
!function() {
var e = 0;
$.each(i, function(t, n) {
e += n.Scripts.length;
});
var t = e, r = function() {
$.ajaxSetup({
async: !0
}), e -= 1, o && o.scriptLoaderCallback(o, t, e + 1), 0 === e && a();
};
e > 0 ? $.each(i, function(e, t) {
t.Scripts.forEach(function(e) {
var o = t.Context + "/" + e;
n.debug("Fetching script: ", o), $.ajaxSetup({
async: !1
}), $.getScript(o).done(function(e) {
n.debug("Loaded script: ", o);
}).fail(function(e, t, r) {
n.info('Failed loading script: "', r.message, '" (<a href="', o, ":", r.lineNumber, '">', o, ":", r.lineNumber, "</a>)");
}).always(r);
});
}) : ($.ajaxSetup({
async: !0
}), a());
}();
}, e.debug = function() {
n.debug("modules"), n.debug(e.modules);
}, e.setLoaderCallback({
scriptLoaderCallback: function(e, t, r) {
n.debug("Total scripts: ", t, " Remaining: ", r);
}
}), e;
}(pluginLoader || {}, window), BootstrapPlugin = function() {
"use strict";
function e() {}
Object.defineProperty(e.prototype, "injector", {
get: function() {
return t._injector;
},
enumerable: !0,
configurable: !0
});
var t = new e();
t.pluginName = "bootstrap-plugin";
var n = Logger.get(t.pluginName), r = angular.module(t.pluginName, []);
return r.config([ "$locationProvider", function(e) {
e.html5Mode(!0);
} ]), r.run([ "documentBase", function(e) {
n.debug("loaded");
} ]), t.documentBase = function() {
var e = $("head").find("base"), t = "/";
return e && e.length > 0 ? t = e.attr("href") : n.warn("Document is missing a 'base' tag, defaulting to '/'"), t;
}, r.factory("documentBase", function() {
return t.documentBase();
}), pluginLoader.addModule("ng"), pluginLoader.addModule("ngSanitize"), pluginLoader.addModule(t.pluginName), $(function() {
if (jQuery.uaMatch = function(e) {
e = e.toLowerCase();
var t = /(chrome)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || e.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e) || [];
return {
browser: t[1] || "",
version: t[2] || "0"
};
}, !jQuery.browser) {
var e = jQuery.uaMatch(navigator.userAgent), r = {};
e.browser && (r[e.browser] = !0, r.version = e.version), r.chrome ? r.webkit = !0 : r.webkit && (r.safari = !0), jQuery.browser = r;
}
pluginLoader.loadPlugins(function() {
if (t.injector) n.debug("Application already bootstrapped"); else {
var e = pluginLoader.getBootstrapElement();
n.debug("Using bootstrap element: ", e), t._injector = angular.bootstrap(e, pluginLoader.getModules(), {
strictDi: !1
}), n.debug("Bootstrapped application");
}
});
}), t;
}();

window.hawtioPluginLoader = pluginLoader, angular.module("openshiftCommonServices", [ "ab-base64" ]).config([ "AuthServiceProvider", function(e) {
e.UserStore("MemoryUserStore");
} ]).constant("API_CFG", _.get(window.OPENSHIFT_CONFIG, "api", {})).constant("APIS_CFG", _.get(window.OPENSHIFT_CONFIG, "apis", {})).constant("AUTH_CFG", _.get(window.OPENSHIFT_CONFIG, "auth", {})).config([ "$httpProvider", "AuthServiceProvider", "RedirectLoginServiceProvider", "AUTH_CFG", function(e, t, n, r) {
e.interceptors.push("AuthInterceptor"), t.LoginService("RedirectLoginService"), t.LogoutService("DeleteTokenLogoutService"), t.UserStore("LocalStorageUserStore"), n.OAuthClientID(r.oauth_client_id), n.OAuthAuthorizeURI(r.oauth_authorize_uri), n.OAuthTokenURI(r.oauth_token_uri), n.OAuthRedirectURI(URI(r.oauth_redirect_base).segment("oauth").toString());
} ]), pluginLoader.addModule("openshiftCommonServices"), pluginLoader.registerPreBootstrapTask(function(e) {
if (_.get(window, "OPENSHIFT_CONFIG.api.k8s.resources")) e(); else {
var t = {
k8s: {},
openshift: {}
}, n = {}, r = [], o = window.location.protocol + "//", i = o + window.OPENSHIFT_CONFIG.api.k8s.hostPort + window.OPENSHIFT_CONFIG.api.k8s.prefix, a = $.get(i + "/v1").done(function(e) {
t.k8s.v1 = _.keyBy(e.resources, "name");
}).fail(function(e, t, n) {
r.push({
data: e,
textStatus: t,
xhr: n,
fatal: !0
});
}), s = o + window.OPENSHIFT_CONFIG.api.openshift.hostPort + window.OPENSHIFT_CONFIG.api.openshift.prefix, c = $.get(s + "/v1").done(function(e) {
t.openshift.v1 = _.keyBy(e.resources, "name");
}).fail(function(e, t, n) {
r.push({
data: e,
textStatus: t,
xhr: n,
fatal: !0
});
}), l = o + window.OPENSHIFT_CONFIG.apis.hostPort + window.OPENSHIFT_CONFIG.apis.prefix, u = [ a, c, $.get(l).then(_.partial(function(e, t, o) {
var i = [];
return _.each(o.groups, function(o) {
var a = {
name: o.name,
preferredVersion: o.preferredVersion.version,
versions: {},
hostPrefix: t
};
n[a.name] = a, _.each(o.versions, function(t) {
var n = t.version;
a.versions[n] = {
version: n,
groupVersion: t.groupVersion
}, i.push($.get(e + "/" + t.groupVersion).done(function(e) {
a.versions[n].resources = _.keyBy(e.resources, "name");
}).fail(function(e, t, n) {
r.push({
data: e,
textStatus: t,
xhr: n
});
}));
});
}), $.when.apply(this, i);
}, l, null), function(e, t, n) {
r.push({
data: e,
textStatus: t,
xhr: n,
fatal: !0
});
}) ];
$.when.apply(this, u).always(function() {
window.OPENSHIFT_CONFIG.api.k8s.resources = t.k8s, window.OPENSHIFT_CONFIG.api.openshift.resources = t.openshift, window.OPENSHIFT_CONFIG.apis.groups = n, r.length && (window.OPENSHIFT_CONFIG.apis.API_DISCOVERY_ERRORS = r), e();
});
}
}), angular.module("openshiftCommonUI", []).constant("BREAKPOINTS", {
screenXsMin: 480,
screenSmMin: 768,
screenMdMin: 992,
screenLgMin: 1200,
screenXlgMin: 1600
}).constant("DNS1123_SUBDOMAIN_VALIDATION", {
pattern: /^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/,
maxlength: 253,
description: "Name must consist of lower-case letters, numbers, periods, and hyphens. It must start and end with a letter or a number."
}).constant("IS_IOS", /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream), pluginLoader.addModule("openshiftCommonUI"), angular.module("openshiftCommonUI").run([ "$templateCache", function(e) {
"use strict";
e.put("src/components/binding/bindApplicationForm.html", '<div class="bind-form">\n  <form>\n    <div class="form-group">\n      <label>\n        <h3>Create a binding for application <strong>{{ctrl.applicationName}}</strong></h3>\n      </label>\n      <span class="help-block">\n        Bindings create a secret containing the necessary information for an application to use a service.\n      </span>\n    </div>\n  </form>\n\n  <label ng-if="!ctrl.allowNoBinding">\n    Select a service:\n  </label>\n  <form name="ctrl.formName">\n    <fieldset>\n      <div class="radio">\n        <div ng-if="ctrl.allowNoBinding" class="bind-service-selection">\n          <label>\n            <input type="radio" ng-model="ctrl.serviceToBind" ng-value="null">\n            Do not bind at this time.\n          </label>\n          <div class="bind-description">\n          <span class="help-block service-instance-name">\n            Bindings can be created later from within a project.\n          </span>\n          </div>\n        </div>\n        <div ng-repeat="serviceInstance in ctrl.bindableServiceInstances" class="bind-service-selection">\n          <label>\n            <input type="radio" ng-model="ctrl.serviceToBind" ng-value="serviceInstance">\n            {{ctrl.serviceClasses[serviceInstance.spec.clusterServiceClassRef.name].spec.externalMetadata.displayName || serviceInstance.spec.clusterServiceClassRef.name}}\n          </label>\n          <div class="bind-description">\n            <span class="pficon pficon-info"\n                  ng-if="!(serviceInstance | isServiceInstanceReady)"\n                  data-content="This service is not yet ready. If you bind to it, then the binding will be pending until the service is ready."\n                  data-toggle="popover"\n                  data-trigger="hover">\n            </span>\n            <span class="help-block service-instance-name">\n              {{serviceInstance.metadata.name}}\n            </span>\n          </div>\n        </div>\n        <h4 ng-if="!ctrl.bindableServiceInstances.length">\n          <span class="pficon pficon-info" aria-hidden="true"></span>\n          <span class="help-block service-instance-name">\n            There are no bindable services in this project\n          </span>\n        </h4>\n      </div>\n    </fieldset>\n  </form>\n</div>\n'), 
e.put("src/components/binding/bindResults.html", '<div ng-if="!ctrl.error && !(ctrl.binding | isBindingFailed)">\n  <div ng-if="ctrl.binding && !(ctrl.binding | isBindingReady)" class="results-status">\n    <span class="fa fa-clock-o text-muted" aria-hidden="true"></span>\n    <span class="sr-only">Pending</span>\n    <div class="results-message">\n      <h3>\n        The binding is being created.\n      </h3>\n      <p class="results-message-details">This may take several minutes.</p>\n    </div>\n  </div>\n  <div ng-if="(ctrl.binding | isBindingReady)">\n    <div class="results-status">\n      <span class="pficon pficon-ok" aria-hidden="true"></span>\n      <span class="sr-only">Success</span>\n      <div class="results-message">\n        <h3>\n          <span ng-if="ctrl.bindType === \'application\'">\n            <strong>{{ctrl.serviceToBind}}</strong> has been bound to\n            <strong>{{ctrl.applicationToBind}}</strong> successfully.\n          </span>\n          <span ng-if="ctrl.bindType !== \'application\'">\n            The binding <strong>{{ctrl.binding.metadata.name}}</strong> has been created successfully.\n          </span>\n        </h3>\n        <p class="results-message-details">\n          The binding operation created the secret\n          <a ng-if="ctrl.secretHref" ng-href="{{ctrl.secretHref}}">{{ctrl.binding.spec.secretName}}</a>\n          <span ng-if="!ctrl.secretHref">{{ctrl.binding.spec.secretName}}</span>\n          that you may need to reference in your application.\n          <span ng-if="ctrl.showPodPresets">Its data will be available to your application as environment variables.</span>\n        </p>\n      </div>\n    </div>\n    <div class="alert alert-info results-info" ng-if="ctrl.bindType === \'application\'">\n      <span class="pficon pficon-info" aria-hidden="true"></span>\n      <span class="sr-only">Info</span>\n      The binding secret will only be available to new pods. You will need to redeploy your application.\n    </div>\n  </div>\n</div>\n<div ng-if="ctrl.error || (ctrl.binding | isBindingFailed)">\n  <div class="results-status">\n    <span class="pficon pficon-error-circle-o text-danger" aria-hidden="true"></span>\n    <span class="sr-only">Error</span>\n    <div class="results-message">\n      <h3>\n        The binding could not be created.\n      </h3>\n    </div>\n  </div>\n  <div ng-if="ctrl.error" class="sub-title">\n    <span ng-if="ctrl.error.data.message">\n      {{ctrl.error.data.message | upperFirst}}\n    </span>\n    <span ng-if="!ctrl.error.data.message">\n      An error occurred creating the binding.\n    </span>\n  </div>\n  <div ng-if="!ctrl.error" class="sub-title">\n    {{ctrl.binding | bindingFailedMessage}}\n  </div>\n</div>\n'), 
e.put("src/components/binding/bindServiceForm.html", '<div class="bind-form">\n  <form>\n    <div class="form-group">\n      <label>\n        <h3>Create a binding for <strong>{{ctrl.serviceClass.spec.externalMetadata.displayName || ctrl.serviceClass.spec.externalName}}</strong></h3>\n      </label>\n      <span class="help-block">Bindings create a secret containing the necessary information for an application to use this service.</span>\n    </div>\n  </form>\n\n  <form ng-if="ctrl.allowNoBinding || ctrl.showPodPresets" name="ctrl.formName" class="mar-bottom-lg">\n    <fieldset>\n      <div class="radio">\n        <label ng-if="ctrl.showPodPresets" class="bind-choice" ng-disabled="!ctrl.applications.length">\n          <input type="radio" ng-model="ctrl.bindType" value="application" ng-disabled="!ctrl.applications.length">\n          Create a secret and inject it into an application\n        </label>\n        <div ng-if="ctrl.showPodPresets" class="application-select">\n          <ui-select ng-model="ctrl.appToBind"\n                     ng-disabled="ctrl.bindType !== \'application\'"\n                     ng-required="ctrl.bindType === \'application\'">\n            <ui-select-match placeholder="{{ctrl.applications.length ? \'Select an application\' : \'There are no applications in this project\'}}">\n              <span>\n                {{$select.selected.metadata.name}}\n                <small class="text-muted">&ndash; {{$select.selected.kind | humanizeKind : true}}</small>\n              </span>\n            </ui-select-match>\n            <ui-select-choices\n              repeat="application in (ctrl.applications) | filter : { metadata: { name: $select.search } } track by (application | uid)"\n              group-by="ctrl.groupByKind">\n              <span ng-bind-html="application.metadata.name | highlight : $select.search"></span>\n            </ui-select-choices>\n          </ui-select>\n        </div>\n        <label class="bind-choice">\n          <input type="radio" ng-model="ctrl.bindType" value="secret-only">\n          Create a secret in <strong>{{ctrl.projectName}}</strong> to be used later\n        </label>\n        <div class="help-block bind-description">\n          Secrets can be referenced later from an application.\n        </div>\n        <label ng-if="ctrl.allowNoBinding" class="bind-choice">\n          <input type="radio" ng-model="ctrl.bindType" value="none">\n          Do not bind at this time\n        </label>\n        <div ng-if="ctrl.allowNoBinding" class="help-block bind-description">\n          Bindings can be created later from within a project.\n        </div>\n      </div>\n    </fieldset>\n  </form>\n</div>\n'), 
e.put("src/components/create-project/createProject.html", '<form name="createProjectForm" novalidate>\n  <fieldset ng-disabled="disableInputs">\n    <div class="form-group">\n      <label for="name" class="required">Name</label>\n      <span ng-class="{\'has-error\': (createProjectForm.name.$error.pattern && createProjectForm.name.$touched) || nameTaken}">\n        <input class="form-control"\n            name="name"\n            id="name"\n            placeholder="my-project"\n            type="text"\n            required\n            take-focus\n            minlength="2"\n            maxlength="63"\n            pattern="[a-z0-9]([-a-z0-9]*[a-z0-9])?"\n            aria-describedby="nameHelp"\n            ng-model="name"\n            ng-model-options="{ updateOn: \'default blur\' }"\n            ng-change="nameTaken = false"\n            autocorrect="off"\n            autocapitalize="off"\n            spellcheck="false">\n      </span>\n      <div>\n        <span class="help-block">A unique name for the project.</span>\n      </div>\n      <div class="has-error">\n        <span id="nameHelp" class="help-block" ng-if="createProjectForm.name.$error.required && createProjectForm.name.$dirty">\n          Name is required.\n        </span>\n      </div>\n      <div class="has-error">\n        <span id="nameHelp" class="help-block" ng-if="createProjectForm.name.$error.minlength && createProjectForm.name.$touched">\n          Name must have at least two characters.\n        </span>\n      </div>\n      <div class="has-error">\n        <span id="nameHelp" class="help-block" ng-if="createProjectForm.name.$error.pattern && createProjectForm.name.$touched">\n          Project names may only contain lower-case letters, numbers, and dashes.\n          They may not start or end with a dash.\n        </span>\n      </div>\n      <div class="has-error">\n        <span class="help-block" ng-if="nameTaken">\n          This name is already in use. Please choose a different name.\n        </span>\n      </div>\n    </div>\n\n    <div class="form-group">\n      <label for="displayName">Display Name</label>\n      <input class="form-control"\n          name="displayName"\n          id="displayName"\n          placeholder="My Project"\n          type="text"\n          ng-model="displayName">\n    </div>\n\n    <div class="form-group">\n      <label for="description">Description</label>\n      <textarea class="form-control"\n          name="description"\n          id="description"\n          placeholder="A short description."\n          ng-model="description"></textarea>\n    </div>\n\n    <div class="button-group">\n      <button type="submit"\n          class="btn btn-primary"\n          ng-class="{\'dialog-btn\': isDialog}"\n          ng-click="createProject()"\n          ng-disabled="createProjectForm.$invalid || nameTaken || disableInputs"\n          value="">\n        Create\n      </button>\n      <button\n          class="btn btn-default"\n          ng-class="{\'dialog-btn\': isDialog}"\n          ng-click="cancelCreateProject()">\n        Cancel\n      </button>\n    </div>\n  </fieldset>\n</form>\n'), 
e.put("src/components/delete-project/delete-project-button.html", '<div class="actions">\n  \x3c!-- Avoid whitespace inside the link --\x3e\n  <a href=""\n     ng-click="$event.stopPropagation(); openDeleteModal()"\n     role="button"\n     class="action-button"\n     ng-attr-aria-disabled="{{disableDelete ? \'true\' : undefined}}"\n     ng-class="{ \'disabled-link\': disableDelete }"\n    ><i class="fa fa-trash-o" aria-hidden="true"\n    ></i><span class="sr-only">Delete Project {{projectName}}</span></a>\n</div>\n'), e.put("src/components/delete-project/delete-project-modal.html", '<div class="delete-resource-modal">\n  \x3c!-- Use a form so that the enter key submits when typing a project name to confirm. --\x3e\n  <form>\n    <div class="modal-header">\n      <button type="button" class="close" data-dismiss="modal" aria-hidden="true" aria-label="Close" ng-click="cancel()">\n        <span class="pficon pficon-close"></span>\n      </button>\n      <h1 class="modal-title">Are you sure you want to delete the project \'<strong>{{project | displayName}}</strong>\'?</h1>\n    </div>\n    <div class="modal-body">\n      <p>\n        This will <strong>delete all resources</strong> associated with\n        the project {{project | displayName}} and <strong>cannot be\n        undone</strong>.  Make sure this is something you really want to do!\n      </p>\n      <div ng-show="typeNameToConfirm">\n        <p>Type <strong>{{project.metadata.name}}</strong> to confirm deletion.</p>\n        <p>\n          <label class="sr-only" for="resource-to-delete">project to delete</label>\n          <input\n              ng-model="confirmName"\n              id="resource-to-delete"\n              type="text"\n              class="form-control input-lg"\n              autocorrect="off"\n              autocapitalize="off"\n              spellcheck="false"\n              autofocus>\n        </p>\n      </div>\n    </div>\n    <div class="modal-footer">\n      <button class="btn btn-default" type="button" ng-click="cancel()">Cancel</button>\n      <button ng-disabled="typeNameToConfirm && confirmName !== project.metadata.name && confirmName !== (project | displayName : false)" class="btn btn-danger" type="submit" ng-click="delete()">Delete</button>\n    </div>\n  </form>\n</div>\n'), 
e.put("src/components/delete-project/delete-project.html", '<a href="javascript:void(0)"\n   ng-click="openDeleteModal()"\n   role="button"\n   ng-attr-aria-disabled="{{disableDelete ? \'true\' : undefined}}"\n   ng-class="{ \'disabled-link\': disableDelete }"\n>{{label || \'Delete\'}}</a>\n'), e.put("src/components/edit-project/editProject.html", '<form name="editProjectForm">\n  <fieldset ng-disabled="disableInputs">\n    <div class="form-group">\n      <label for="displayName">Display Name</label>\n      <input class="form-control"\n             name="displayName"\n             id="displayName"\n             placeholder="My Project"\n             type="text"\n             ng-model="editableFields.displayName">\n    </div>\n\n    <div class="form-group">\n      <label for="description">Description</label>\n                    <textarea class="form-control"\n                              name="description"\n                              id="description"\n                              placeholder="A short description."\n                              ng-model="editableFields.description"></textarea>\n    </div>\n\n    <div class="button-group">\n      <button type="submit"\n              class="btn btn-primary"\n              ng-class="{\'dialog-btn\': isDialog}"\n              ng-click="update()"\n              ng-disabled="editProjectForm.$invalid || disableInputs"\n              value="">{{submitButtonLabel}}</button>\n      <button\n          class="btn btn-default"\n          ng-class="{\'dialog-btn\': isDialog}"\n          ng-click="cancelEditProject()">\n        Cancel\n      </button>\n    </div>\n  </fieldset>\n</form>\n'), 
e.put("src/components/origin-modal-popup/origin-modal-popup.html", '<div class="origin-modal-popup tile-click-prevent" ng-if="$ctrl.shown" ng-style="$ctrl.positionStyle"\n     ng-class="{\'position-above\': $ctrl.showAbove, \'position-left\': $ctrl.showLeft}">\n  <h4 class="origin-modal-popup-title">\n    {{$ctrl.modalTitle}}\n  </h4>\n  <div ng-transclude></div>\n  <a href="" class="origin-modal-popup-close" ng-click="$ctrl.onClose()">\n    <span class="pficon pficon-close"></span>\n  </a>\n</div>\n'), e.put("src/components/toast-notifications/toast-notifications.html", '<div class="toast-notifications-list-pf">\n  <div\n    ng-repeat="(notificationID, notification) in notifications track by notification.trackByID"\n    ng-if="!notification.hidden || notification.isHover"\n       ng-mouseenter="setHover(notification, true)" ng-mouseleave="setHover(notification, false)">\n    <div class="toast-pf alert {{notification.type | alertStatus}}" ng-class="{\'alert-dismissable\': !hideCloseButton}">\n      <button ng-if="!hideCloseButton" type="button" class="close" ng-click="close(notification)">\n        <span class="pficon pficon-close" aria-hidden="true"></span>\n        <span class="sr-only">Close</span>\n      </button>\n      <span class="{{notification.type | alertIcon}}" aria-hidden="true"></span>\n      <span class="sr-only">{{notification.type}}</span>\n      <span class="toast-notification-message" ng-if="notification.message">{{notification.message}}</span>\n      <div ng-if="notification.details" class="toast-notification-details">\n        <truncate-long-text\n          limit="200"\n          content="notification.details"\n          use-word-boundary="true"\n          expandable="true"\n          hide-collapse="true">\n        </truncate-long-text>\n      </div>\n      <span ng-repeat="link in notification.links">\n        <a ng-if="!link.href" href="" ng-click="onClick(notification, link)" role="button">{{link.label}}</a>\n        <a ng-if="link.href" ng-href="{{link.href}}" ng-attr-target="{{link.target}}">{{link.label}}</a>\n        <span ng-if="!$last" class="toast-action-divider">|</span>\n      </span>\n    </div>\n  </div>\n</div>\n'), 
e.put("src/components/truncate-long-text/truncateLongText.html", '\x3c!--\n  Do not remove class `truncated-content` (here or below) even though it\'s not\n  styled directly in origin-web-common.  `truncated-content` is used by\n  origin-web-console in certain contexts.\n\n  highlightKeywords and linkify are mutually exclusive options\n--\x3e\n<span ng-if="!truncated">\n  <span ng-if="!linkify || (highlightKeywords | size)" ng-bind-html="content | highlightKeywords : keywords" class="truncated-content"></span>\n  <span ng-if="linkify && !(highlightKeywords | size)" ng-bind-html="content | linkify : \'_blank\'" class="truncated-content"></span>\n</span>\n\x3c!-- To avoid truncating in middle of a link, we only optionally apply linkify to expanded content --\x3e\n<span ng-if="truncated">\n  <span ng-if="!toggles.expanded">\n    <span ng-attr-title="{{content}}" class="truncation-block">\n      <span ng-bind-html="truncatedContent | highlightKeywords : keywords" class="truncated-content"></span>&hellip;\n    </span>\n    <a ng-if="expandable" href="" ng-click="toggles.expanded = true" class="truncation-expand-link">See All</a>\n  </span>\n  <span ng-if="toggles.expanded">\n    <span ng-if="!linkify || (highlightKeywords | size)"\n          ng-bind-html="content | highlightKeywords : keywords"\n          class="truncated-content"></span>\n    <span ng-if="linkify && !(highlightKeywords | size)"\n          ng-bind-html="content | linkify : \'_blank\'"\n          class="truncated-content"></span>\n    <a href="" ng-if="!hideCollapse" ng-click="toggles.expanded = false" class="truncation-collapse-link">Collapse</a>\n  </span>\n</span>\n');
} ]), angular.module("openshiftCommonServices").constant("API_DEDUPLICATION", {
groups: [ {
group: "authorization.openshift.io"
} ],
kinds: [ {
group: "extensions",
kind: "DaemonSet"
}, {
group: "extensions",
kind: "HorizontalPodAutoscaler"
}, {
group: "extensions",
kind: "NetworkPolicy"
}, {
group: "extensions",
kind: "ReplicationControllerDummy"
} ]
}), angular.module("openshiftCommonServices").constant("API_PREFERRED_VERSIONS", {
appliedclusterresourcequotas: {
group: "quota.openshift.io",
version: "v1",
resource: "appliedclusterresourcequotas"
},
builds: {
group: "build.openshift.io",
version: "v1",
resource: "builds"
},
"builds/clone": {
group: "build.openshift.io",
version: "v1",
resource: "builds/clone"
},
"builds/log": {
group: "build.openshift.io",
version: "v1",
resource: "builds/log"
},
"buildconfigs/instantiate": {
group: "build.openshift.io",
version: "v1",
resource: "buildconfigs/instantiate"
},
buildconfigs: {
group: "build.openshift.io",
version: "v1",
resource: "buildconfigs"
},
configmaps: {
version: "v1",
resource: "configmaps"
},
clusterroles: {
group: "rbac.authorization.k8s.io",
version: "v1",
resource: "clusterroles"
},
clusterserviceclasses: {
group: "servicecatalog.k8s.io",
version: "v1beta1",
resource: "clusterserviceclasses"
},
clusterserviceplans: {
group: "servicecatalog.k8s.io",
version: "v1beta1",
resource: "clusterserviceplans"
},
daemonsets: {
group: "apps",
version: "v1",
resource: "daemonsets"
},
deployments: {
group: "apps",
version: "v1beta1",
resource: "deployments"
},
deploymentconfigs: {
group: "apps.openshift.io",
version: "v1",
resource: "deploymentconfigs"
},
"deploymentconfigs/instantiate": {
group: "apps.openshift.io",
version: "v1",
resource: "deploymentconfigs/instantiate"
},
"deploymentconfigs/rollback": {
group: "apps.openshift.io",
version: "v1",
resource: "deploymentconfigs/rollback"
},
"deploymentconfigs/log": {
group: "apps.openshift.io",
version: "v1",
resource: "deploymentconfigs/log"
},
endpoints: {
version: "v1",
resource: "endpoints"
},
events: {
version: "v1",
resource: "events"
},
horizontalpodautoscalers: {
group: "autoscaling",
version: "v1",
resource: "horizontalpodautoscalers"
},
imagestreams: {
group: "image.openshift.io",
version: "v1",
resource: "imagestreams"
},
imagestreamtags: {
group: "image.openshift.io",
version: "v1",
resource: "imagestreamtags"
},
imagestreamimages: {
group: "image.openshift.io",
version: "v1",
resource: "imagestreamimages"
},
imagestreamimports: {
group: "image.openshift.io",
version: "v1",
resource: "imagestreamimports"
},
limitranges: {
version: "v1",
resource: "limitranges"
},
mobileclients: {
group: "mobile.k8s.io",
version: "v1alpha1",
resource: "mobileclients"
},
oauthaccesstokens: {
group: "oauth.openshift.io",
version: "v1",
resource: "oauthaccesstokens"
},
pods: {
version: "v1",
resource: "pods"
},
"pods/log": {
version: "v1",
resource: "pods/log"
},
processedtemplates: {
group: "template.openshift.io",
version: "v1",
resource: "processedtemplates"
},
projects: {
group: "project.openshift.io",
version: "v1",
resource: "projects"
},
projectrequests: {
group: "project.openshift.io",
version: "v1",
resource: "projectrequests"
},
persistentvolumeclaims: {
version: "v1",
resource: "persistentvolumeclaims"
},
replicasets: {
group: "apps",
version: "v1",
resource: "replicasets"
},
replicationcontrollers: {
version: "v1",
resource: "replicationcontrollers"
},
resourcequotas: {
version: "v1",
resource: "resourcequotas"
},
rolebindings: {
group: "rbac.authorization.k8s.io",
version: "v1",
resource: "rolebindings"
},
roles: {
group: "rbac.authorization.k8s.io",
version: "v1",
resource: "roles"
},
routes: {
group: "route.openshift.io",
version: "v1",
resource: "routes"
},
secrets: {
version: "v1",
resource: "secrets"
},
selfsubjectrulesreviews: {
group: "authorization.openshift.io",
version: "v1",
resource: "selfsubjectrulesreviews"
},
services: {
version: "v1",
resource: "services"
},
serviceaccounts: {
version: "v1",
resource: "serviceaccounts"
},
servicebindings: {
group: "servicecatalog.k8s.io",
version: "v1beta1",
resource: "servicebindings"
},
serviceinstances: {
group: "servicecatalog.k8s.io",
version: "v1beta1",
resource: "serviceinstances"
},
statefulsets: {
group: "apps",
version: "v1beta1",
resource: "statefulsets"
},
storageclasses: {
group: "storage.k8s.io",
version: "v1",
resource: "storageclasses"
},
templates: {
group: "template.openshift.io",
verison: "v1",
resource: "templates"
},
users: {
group: "user.openshift.io",
version: "v1",
resource: "users"
}
}), angular.module("openshiftCommonUI").filter("alertStatus", function() {
return function(e) {
switch ((e = e || "").toLowerCase()) {
case "error":
return "alert-danger";

case "warning":
return "alert-warning";

case "success":
return "alert-success";

case "normal":
return "alert-info";
}
return "alert-info";
};
}).filter("alertIcon", function() {
return function(e) {
switch ((e = e || "").toLowerCase()) {
case "error":
return "pficon pficon-error-circle-o";

case "warning":
return "pficon pficon-warning-triangle-o";

case "success":
return "pficon pficon-ok";

case "normal":
return "pficon pficon-info";
}
return "pficon pficon-info";
};
}), angular.module("openshiftCommonUI").filter("annotationName", function() {
var e = {
buildConfig: [ "openshift.io/build-config.name" ],
deploymentConfig: [ "openshift.io/deployment-config.name" ],
deployment: [ "openshift.io/deployment.name" ],
pod: [ "openshift.io/deployer-pod.name" ],
deployerPod: [ "openshift.io/deployer-pod.name" ],
deployerPodFor: [ "openshift.io/deployer-pod-for.name" ],
deploymentStatus: [ "openshift.io/deployment.phase" ],
deploymentStatusReason: [ "openshift.io/deployment.status-reason" ],
deploymentCancelled: [ "openshift.io/deployment.cancelled" ],
encodedDeploymentConfig: [ "openshift.io/encoded-deployment-config" ],
deploymentVersion: [ "openshift.io/deployment-config.latest-version" ],
displayName: [ "openshift.io/display-name" ],
description: [ "openshift.io/description" ],
buildNumber: [ "openshift.io/build.number" ],
buildPod: [ "openshift.io/build.pod-name" ],
jenkinsBuildURL: [ "openshift.io/jenkins-build-uri" ],
jenkinsLogURL: [ "openshift.io/jenkins-log-url" ],
jenkinsStatus: [ "openshift.io/jenkins-status-json" ],
loggingUIHostname: [ "openshift.io/logging.ui.hostname" ],
loggingDataPrefix: [ "openshift.io/logging.data.prefix" ],
idledAt: [ "idling.alpha.openshift.io/idled-at" ],
idledPreviousScale: [ "idling.alpha.openshift.io/previous-scale" ],
systemOnly: [ "authorization.openshift.io/system-only" ]
};
return function(t) {
return e[t] || null;
};
}).filter("annotation", [ "annotationNameFilter", function(e) {
return function(t, n) {
if (t && t.metadata && t.metadata.annotations) {
if (void 0 !== t.metadata.annotations[n]) return t.metadata.annotations[n];
for (var r = e(n) || [], o = 0; o < r.length; o++) {
var i = r[o];
if (void 0 !== t.metadata.annotations[i]) return t.metadata.annotations[i];
}
return null;
}
return null;
};
} ]).filter("imageStreamTagAnnotation", function() {
return function(e, t, n) {
if (n = n || "latest", e && e.spec && e.spec.tags) for (var r = e.spec.tags, o = 0; o < _.size(r); ++o) {
var i = r[o];
if (n === i.name && i.annotations) return i.annotations[t];
}
return null;
};
}).filter("imageStreamTagTags", [ "imageStreamTagAnnotationFilter", function(e) {
return function(t, n) {
var r = e(t, "tags", n);
return r ? r.split(/\s*,\s*/) : [];
};
} ]).filter("imageStreamTagIconClass", [ "imageStreamTagAnnotationFilter", function(e) {
return function(t, n) {
var r = e(t, "iconClass", n);
return r || "fa fa-cube";
};
} ]), angular.module("openshiftCommonUI").filter("canI", [ "AuthorizationService", function(e) {
return function(t, n, r) {
return e.canI(t, n, r);
};
} ]).filter("canIAddToProject", [ "AuthorizationService", function(e) {
return function(t) {
return e.canIAddToProject(t);
};
} ]), angular.module("openshiftCommonUI").filter("isNewerResource", function() {
return function(e, t) {
var n = _.get(e, "metadata.creationTimestamp");
if (!n) return !1;
var r = _.get(t, "metadata.creationTimestamp");
return !r || n > r;
};
}).filter("mostRecent", [ "isNewerResourceFilter", function(e) {
return function(t) {
var n = null;
return _.each(t, function(t) {
n && !e(t, n) || (n = t);
}), n;
};
} ]).filter("orderObjectsByDate", [ "toArrayFilter", function(e) {
return function(t, n) {
return (t = e(t)).sort(function(e, t) {
if (!(e.metadata && e.metadata.creationTimestamp && t.metadata && t.metadata.creationTimestamp)) throw "orderObjectsByDate expects all objects to have the field metadata.creationTimestamp";
return e.metadata.creationTimestamp < t.metadata.creationTimestamp ? n ? 1 : -1 : e.metadata.creationTimestamp > t.metadata.creationTimestamp ? n ? -1 : 1 : 0;
}), t;
};
} ]), angular.module("openshiftCommonUI").filter("highlightKeywords", [ "KeywordService", function(e) {
return function(t, n, r) {
if (!t) return t;
if (_.isEmpty(n)) return _.escape(t);
_.isString(n) && (n = e.generateKeywords(n));
for (var o, i = _.map(n, function(e) {
return _.isRegExp(e) ? e.source : _.escapeRegExp(e);
}).join("|"), a = "", s = 0, c = r ? "g" : "ig", l = new RegExp(i, c); null !== (o = l.exec(t)); ) s < o.index && (a += _.escape(t.substring(s, o.index))), a += "<mark>" + _.escape(o[0]) + "</mark>", s = l.lastIndex;
return s < t.length && (a += _.escape(t.substring(s))), a;
};
} ]), angular.module("openshiftCommonUI").filter("imageForIconClass", [ "$window", "isAbsoluteURLFilter", function(e, t) {
return function(n) {
if (!n) return "";
var r = _.get(e, [ "OPENSHIFT_CONSTANTS", "LOGOS", n ]);
if (!r) return "";
var o = _.get(e, "OPENSHIFT_CONSTANTS.LOGO_BASE_URL");
return !o || t(r) ? r : (_.endsWith(o, "/") || (o += "/"), o + r);
};
} ]), angular.module("openshiftCommonUI").filter("isAbsoluteURL", function() {
return function(e) {
if (!e || !_.isString(e)) return !1;
var t = new URI(e), n = t.protocol();
return t.is("absolute") && ("http" === n || "https" === n);
};
}), angular.module("openshiftCommonUI").filter("linkify", [ "HTMLService", function(e) {
return function(t, n, r) {
return e.linkify(t, n, r);
};
} ]), angular.module("openshiftCommonUI").filter("normalizeIconClass", function() {
return function(e) {
return _.startsWith(e, "icon-") ? "font-icon " + e : e;
};
}), angular.module("openshiftCommonUI").filter("parseJSON", function() {
return function(e) {
if (!e) return null;
try {
var t = JSON.parse(e);
return "object" == typeof t ? t : null;
} catch (e) {
return null;
}
};
}), angular.module("openshiftCommonUI").filter("preferredVersion", [ "APIService", function(e) {
return e.getPreferredVersion;
} ]), angular.module("openshiftCommonUI").filter("prettifyJSON", [ "parseJSONFilter", function(e) {
return function(t) {
var n = e(t);
return n ? JSON.stringify(n, null, 4) : t;
};
} ]), angular.module("openshiftCommonUI").filter("uid", function() {
return function(e) {
return e && e.metadata && e.metadata.uid ? e.metadata.uid : e;
};
}).filter("labelName", function() {
var e = {
buildConfig: [ "openshift.io/build-config.name" ],
deploymentConfig: [ "openshift.io/deployment-config.name" ]
};
return function(t) {
return e[t];
};
}).filter("description", [ "annotationFilter", function(e) {
return function(t) {
return e(t, "openshift.io/description") || e(t, "kubernetes.io/description") || e(t, "description");
};
} ]).filter("displayName", [ "annotationFilter", function(e) {
return function(t, n) {
var r = e(t, "displayName");
return r || n ? r : t && t.metadata ? t.metadata.name : null;
};
} ]).filter("uniqueDisplayName", [ "displayNameFilter", function(e) {
function t(t) {
var n = {};
return angular.forEach(t, function(t, r) {
var o = e(t);
n[o] = (n[o] || 0) + 1;
}), n;
}
return function(n, r) {
if (!n) return "";
var o = e(n), i = n.metadata.name;
return o !== i && t(r)[o] > 1 ? o + " (" + i + ")" : o;
};
} ]).filter("searchProjects", [ "displayNameFilter", function(e) {
return function(t, n) {
return n ? (n = n.toLowerCase(), _.filter(t, function(t) {
if (_.includes(t.metadata.name, n)) return !0;
var r = e(t, !0);
return !(!r || !_.includes(r.toLowerCase(), n));
})) : t;
};
} ]).filter("label", function() {
return function(e, t) {
return e && e.metadata && e.metadata.labels ? e.metadata.labels[t] : null;
};
}).filter("humanizeKind", [ "startCaseFilter", function(e) {
return function(e, t) {
if (!e) return e;
if ("ServiceInstance" === e) return t ? "Provisioned Service" : "provisioned service";
var n = _.startCase(e);
return t ? n : n.toLowerCase();
};
} ]).filter("statusCondition", function() {
return function(e, t) {
return e ? _.find(_.get(e, "status.conditions"), {
type: t
}) : null;
};
}).filter("isServiceInstanceReady", [ "statusConditionFilter", function(e) {
return function(t) {
return "True" === _.get(e(t, "Ready"), "status");
};
} ]).filter("serviceInstanceReadyMessage", [ "statusConditionFilter", function(e) {
return function(t) {
return _.get(e(t, "Ready"), "message");
};
} ]).filter("isServiceInstanceFailed", [ "statusConditionFilter", function(e) {
return function(t) {
return "True" === _.get(e(t, "Failed"), "status");
};
} ]).filter("serviceInstanceFailedMessage", [ "isServiceInstanceFailedFilter", "statusConditionFilter", function(e, t) {
return function(n) {
if (e(n)) return _.get(t(n, "Failed"), "message");
};
} ]).filter("isBindingReady", [ "isServiceInstanceReadyFilter", function(e) {
return e;
} ]).filter("isBindingFailed", [ "isServiceInstanceFailedFilter", function(e) {
return e;
} ]).filter("bindingFailedMessage", [ "serviceInstanceFailedMessageFilter", function(e) {
return e;
} ]).filter("bindingReadyMessage", [ "serviceInstanceReadyMessageFilter", function(e) {
return e;
} ]).filter("hasDeployment", [ "annotationFilter", function(e) {
return function(t) {
return !!e(t, "deployment.kubernetes.io/revision");
};
} ]).filter("hasDeploymentConfig", [ "annotationFilter", function(e) {
return function(t) {
return !!e(t, "deploymentConfig");
};
} ]).filter("serviceClassDisplayName", function() {
return function(e) {
var t = _.get(e, "spec.externalMetadata.displayName");
return t || _.get(e, "spec.externalName");
};
}).filter("serviceInstanceDisplayName", [ "serviceClassDisplayNameFilter", function(e) {
return function(t, n) {
if (n) return e(n);
var r = _.get(t, "spec.clusterServiceClassExternalName");
return r || _.get(t, "metadata.name");
};
} ]).filter("serviceInstanceStatus", [ "isServiceInstanceReadyFilter", function(e) {
return function(t) {
var n = "Pending", r = _.get(t, "status.conditions");
return _.find(r, {
type: "Failed",
status: "True"
}) ? n = "Failed" : e(t) && (n = "Ready"), n;
};
} ]), angular.module("openshiftCommonUI").filter("camelToLower", function() {
return function(e) {
return e ? _.startCase(e).toLowerCase() : "";
};
}).filter("upperFirst", function() {
return _.upperFirst;
}).filter("sentenceCase", [ "camelToLowerFilter", function(e) {
return function(t) {
var n = e(t);
return _.upperFirst(n);
};
} ]).filter("startCase", function() {
return _.startCase;
}).filter("capitalize", function() {
return _.capitalize;
}).filter("isMultiline", function() {
return function(e, t) {
if (!e) return !1;
var n = e.search(/\r|\n/);
return -1 !== n && (!t || n !== e.length - 1);
};
}), angular.module("openshiftCommonUI").filter("truncate", function() {
return function(e, t, n, r) {
if ("string" != typeof e) return e;
var o = e;
if (t && (o = o.substring(0, t)), r) {
var i = e.split("\n", r).join("\n").length;
o = o.substring(0, i);
}
if (!1 !== n) {
var a = Math.max(4, t - 10), s = o.lastIndexOf(" ");
s >= a && -1 !== s && (o = o.substring(0, s));
}
return o;
};
}), angular.module("openshiftCommonUI").filter("toArray", function() {
return _.toArray;
}).filter("size", function() {
return _.size;
}).filter("hashSize", function() {
return function(e) {
return e ? Object.keys(e).length : 0;
};
}).filter("filterCollection", function() {
return function(e, t) {
return e && t ? _.filter(e, t) : e;
};
}).filter("generateName", function() {
return function(e, t) {
return e || (e = ""), t || (t = 5), e + Math.round(Math.pow(36, t + 1) - Math.random() * Math.pow(36, t)).toString(36).slice(1);
};
}).filter("getErrorDetails", [ "upperFirstFilter", function(e) {
return function(t, n) {
if (!t) return "";
var r = t.data || {};
if (r.message) return n ? e(r.message) : r.message;
var o = t.status || r.status;
return o ? "Status: " + o : "";
};
} ]), angular.module("openshiftCommonServices").service("AlertMessageService", function() {
var e = function(e, t) {
return t ? "hide/alert/" + t + "/" + e : "hide/alert/" + e;
};
return {
isAlertPermanentlyHidden: function(t, n) {
var r = e(t, n);
return "true" === localStorage.getItem(r);
},
permanentlyHideAlert: function(t, n) {
var r = e(t, n);
localStorage.setItem(r, "true");
}
};
}), ResourceGroupVersion.prototype.toString = function() {
var e = this.resource;
return this.group && (e += "/" + this.group), this.version && (e += "/" + this.version), e;
}, ResourceGroupVersion.prototype.primaryResource = function() {
if (!this.resource) return "";
var e = this.resource.indexOf("/");
return -1 === e ? this.resource : this.resource.substring(0, e);
}, ResourceGroupVersion.prototype.subresources = function() {
var e = (this.resource || "").split("/");
return e.shift(), e;
}, ResourceGroupVersion.prototype.equals = function(e, t, n) {
return this.resource === e && (1 === arguments.length || this.group === t && (2 === arguments.length || this.version === n));
}, angular.module("openshiftCommonServices").factory("APIService", [ "API_CFG", "APIS_CFG", "API_PREFERRED_VERSIONS", "API_DEDUPLICATION", "AuthService", "Constants", "Logger", "$q", "$http", "$filter", "$window", function(e, t, n, r, o, i, a, s, c, l, u) {
function d(e) {
if (!e) return e;
var t = e.indexOf("/");
return -1 === t ? e.toLowerCase() : e.substring(0, t).toLowerCase() + e.substring(t);
}
function p(e, t) {
if (!e) return "";
var n = e;
return t && (n = l("humanizeKind")(n)), "endpoints" === (n = String(n).toLowerCase()) || "securitycontextconstraints" === n || ("s" === n[n.length - 1] ? n += "es" : "y" === n[n.length - 1] ? n = n.substring(0, n.length - 1) + "ies" : n += "s"), n;
}
var f = {
"": "v1",
extensions: "v1beta1"
}, g = function(e) {
if (e instanceof ResourceGroupVersion) return e;
var n, r, o;
return angular.isString(e) ? (n = d(e), o = f[r = ""]) : e && e.resource && (n = d(e.resource), r = e.group || "", o = e.version || f[r] || _.get(t, [ "groups", r, "preferredVersion" ])), new ResourceGroupVersion(n, r, o);
}, m = function(e) {
if (e) {
var t = e.split("/");
return 1 === t.length ? "v1" === t[0] ? {
group: "",
version: t[0]
} : {
group: t[0],
version: ""
} : 2 === t.length ? {
group: t[0],
version: t[1]
} : void a.warn('Invalid apiVersion "' + e + '"');
}
}, h = function(e, t) {
return !(!_.find(r.kinds, {
group: e,
kind: t
}) && !_.find(r.groups, {
group: e
}));
}, v = function(n) {
var r = [], o = _.map(i.AVAILABLE_KINDS_BLACKLIST, function(e) {
return _.isString(e) ? {
kind: e,
group: ""
} : e;
});
return _.each(_.pickBy(e, function(e, t) {
return "openshift" !== t;
}), function(e) {
_.each(e.resources.v1, function(e) {
if (e.namespaced || n) {
if (_.includes(e.name, "/") || _.find(o, {
kind: e.kind,
group: ""
})) return;
r.push({
kind: e.kind,
group: ""
});
}
});
}), _.each(t.groups, function(e) {
var t = f[e.name] || e.preferredVersion;
_.each(e.versions[t].resources, function(t) {
_.includes(t.name, "/") || _.find(o, {
kind: t.kind,
group: e.name
}) || h(e.name, t.kind) || (t.namespaced || n) && r.push({
kind: t.kind,
group: e.name
});
});
}), _.uniqBy(r, function(e) {
return e.group + "/" + e.kind;
});
}, b = v(!1), y = v(!0);
return {
toAPIVersion: function(e) {
return e.group ? e.group + "/" + e.version : e.version;
},
toResourceGroupVersion: g,
parseGroupVersion: m,
objectToResourceGroupVersion: function(e) {
if (e && e.kind && e.apiVersion) {
var t = p(e.kind);
if (t) {
var n = m(e.apiVersion);
if (n) return new ResourceGroupVersion(t, n.group, n.version);
}
}
},
deriveTargetResource: function(e, t) {
if (e && t) {
var n = p(t.kind), r = m(t.apiVersion), o = g(e);
if (n && r && o) return angular.isString(e) ? (o.equals(n) && (o.group = r.group, o.version = r.version), o) : (o.equals(n, r.group) && (o.version = r.version), o);
}
},
kindToResource: p,
kindToResourceGroupVersion: function(e) {
return g({
resource: p(e.kind),
group: e.group
});
},
apiInfo: function(n) {
if (t.API_DISCOVERY_ERRORS) {
if (_.every(t.API_DISCOVERY_ERRORS, function(e) {
return 0 === _.get(e, "data.status");
}) && !o.isLoggedIn()) return void o.withUser();
var r = !1;
if (_.each(t.API_DISCOVERY_ERRORS, function(e) {
if (e.fatal) return a.error("API discovery failed (fatal error)", e), void (r = !0);
a.warn("API discovery failed", e);
}), r) return void (u.location.href = URI("error").query({
error_description: "Unable to load details about the server. If the problem continues, please contact your system administrator.",
error: "API_DISCOVERY"
}).toString());
}
var i, s = (n = g(n)).primaryResource();
if (n.group) {
if (!(i = _.get(t, [ "groups", n.group, "versions", n.version, "resources", s ]))) return;
var c = _.get(t, [ "groups", n.group, "hostPrefix" ]) || t;
return {
resource: n.resource,
group: n.group,
version: n.version,
protocol: c.protocol,
hostPort: c.hostPort,
prefix: c.prefix,
namespaced: i.namespaced,
verbs: i.verbs
};
}
var l;
for (var d in e) if (l = e[d], i = _.get(l, [ "resources", n.version, s ])) return {
resource: n.resource,
version: n.version,
hostPort: l.hostPort,
prefix: l.prefix,
namespaced: i.namespaced,
verbs: i.verbs
};
},
invalidObjectKindOrVersion: function(e) {
var t = "<none>", n = "<none>";
return e && e.kind && (t = e.kind), e && e.apiVersion && (n = e.apiVersion), "Invalid kind (" + t + ") or API version (" + n + ")";
},
unsupportedObjectKindOrVersion: function(e) {
var t = "<none>", n = "<none>";
return e && e.kind && (t = e.kind), e && e.apiVersion && (n = e.apiVersion), "The API version " + n + " for kind " + t + " is not supported by this server";
},
availableKinds: function(e) {
return e ? y : b;
},
getPreferredVersion: function(e) {
var t = n[e];
return t || a.log("No preferred version for ", e), t;
}
};
} ]), angular.module("openshiftCommonServices").service("ApplicationsService", [ "$q", "APIService", "DataService", function(e, t, n) {
var r = t.getPreferredVersion("deployments"), o = t.getPreferredVersion("deploymentconfigs"), i = t.getPreferredVersion("replicationcontrollers"), a = t.getPreferredVersion("replicasets"), s = t.getPreferredVersion("statefulsets"), c = function(e) {
return n.list(i, e, null, {
http: {
params: {
labelSelector: "!openshift.io/deployment-config.name"
}
}
});
}, l = function(e) {
return n.list(a, e, null, {
http: {
params: {
labelSelector: "!pod-template-hash"
}
}
});
};
return {
listStandaloneReplicationControllers: c,
listStandaloneReplicaSets: l,
getApplications: function(t) {
var i = e.defer(), a = [];
return a.push(n.list(o, t)), a.push(c(t)), a.push(n.list(r, t)), a.push(l(t)), a.push(n.list(s, t)), e.all(a).then(_.spread(function(e, t, n, r, o) {
var a = _.toArray(e.by("metadata.name")), s = _.toArray(t.by("metadata.name")), c = _.toArray(n.by("metadata.name")), l = _.toArray(r.by("metadata.name")), u = _.toArray(o.by("metadata.name")), d = a.concat(c).concat(s).concat(l).concat(u);
i.resolve(_.sortBy(d, [ "metadata.name", "kind" ]));
}), function(e) {
i.reject(e);
}), i.promise;
}
};
} ]), angular.module("openshiftCommonServices").provider("AuthService", function() {
var e = "";
this.UserStore = function(t) {
return t && (e = t), e;
};
var t = "";
this.LoginService = function(e) {
return e && (t = e), t;
};
var n = "";
this.LogoutService = function(e) {
return e && (n = e), n;
};
var r = function(e, t, n) {
if (t) return angular.isString(t) ? e.get(t) : e.invoke(t);
throw n + " not set";
};
this.$get = [ "$q", "$injector", "$log", "$rootScope", "Logger", "base64", function(o, i, a, s, c, l) {
var u = c.get("auth");
u.log("AuthServiceProvider.$get", arguments);
var d = $.Callbacks(), p = $.Callbacks(), f = $.Callbacks(), g = null, m = null, h = r(i, e, "AuthServiceProvider.UserStore()");
h.available() || c.error("AuthServiceProvider.$get user store " + e + " not available");
var v = r(i, t, "AuthServiceProvider.LoginService()"), b = r(i, n, "AuthServiceProvider.LogoutService()");
return {
UserStore: function() {
return h;
},
isLoggedIn: function() {
return !!h.getUser();
},
withUser: function() {
var e = h.getUser();
return e ? (s.user = e, u.log("AuthService.withUser()", e), o.when(e)) : (u.log("AuthService.withUser(), calling startLogin()"), this.startLogin());
},
setUser: function(e, t, n) {
u.log("AuthService.setUser()", e, t, n);
var r = h.getUser();
h.setUser(e, n), h.setToken(t, n), s.user = e, (r && r.metadata && r.metadata.name) !== (e && e.metadata && e.metadata.name) && (u.log("AuthService.setUser(), user changed", r, e), f.fire(e));
},
requestRequiresAuth: function(e) {
var t = !!e.auth;
return u.log("AuthService.requestRequiresAuth()", e.url.toString(), t), t;
},
addAuthToRequest: function(e) {
var t = "";
return e && e.auth && e.auth.token ? (t = e.auth.token, u.log("AuthService.addAuthToRequest(), using token from request config", t)) : (t = h.getToken(), u.log("AuthService.addAuthToRequest(), using token from user store", t)), t ? ("WATCH" === e.method ? (e.protocols = e.protocols || [], _.isArray(e.protocols) || (e.protocols = [ e.protocols ]), 0 == e.protocols.length && e.protocols.unshift("undefined"), e.protocols.unshift("base64url.bearer.authorization.k8s.io." + l.urlencode(t)), u.log("AuthService.addAuthToRequest(), added token protocol", e.protocols)) : (e.headers.Authorization = "Bearer " + t, u.log("AuthService.addAuthToRequest(), added token header", e.headers.Authorization)), !0) : (u.log("AuthService.addAuthToRequest(), no token available"), !1);
},
startLogin: function() {
if (g) return u.log("Login already in progress"), g;
var e = this;
return g = v.login().then(function(t) {
e.setUser(t.user, t.token, t.ttl), d.fire(t.user);
}).catch(function(e) {
c.error(e);
}).finally(function() {
g = null;
});
},
startLogout: function() {
if (m) return u.log("Logout already in progress"), m;
var e = this, t = h.getUser(), n = h.getToken(), r = this.isLoggedIn();
return m = b.logout(t, n).then(function() {
u.log("Logout service success");
}).catch(function(e) {
u.error("Logout service error", e);
}).finally(function() {
e.setUser(null, null);
var t = e.isLoggedIn();
r && !t && p.fire(), m = null;
});
},
onLogin: function(e) {
d.add(e);
},
onLogout: function(e) {
p.add(e);
},
onUserChanged: function(e) {
f.add(e);
}
};
} ];
}).factory("AuthInterceptor", [ "$q", "AuthService", function(e, t) {
var n = [];
return {
request: function(r) {
if (!t.requestRequiresAuth(r)) return r;
if (t.addAuthToRequest(r)) return r;
if (r.auth && !1 === r.auth.triggerLogin) return r;
var o = e.defer();
return n.push([ o, r, "request" ]), t.startLogin(), o.promise;
},
responseError: function(r) {
var o = r.config.auth || {};
if (!t.requestRequiresAuth(r.config)) return e.reject(r);
if (!1 === o.triggerLogin) return e.reject(r);
switch (r.status) {
case 401:
var i = e.defer();
return n.push([ i, r.config, "responseError" ]), t.startLogin(), i.promise;

default:
return e.reject(r);
}
}
};
} ]), angular.module("openshiftCommonServices").factory("AuthorizationService", [ "$q", "$cacheFactory", "Logger", "$interval", "APIService", "DataService", function(e, t, n, r, o, i) {
var a = null, s = t("rulesCache", {
number: 10
}), c = !1, l = [ "localresourceaccessreviews", "localsubjectaccessreviews", "resourceaccessreviews", "selfsubjectaccessreviews", "selfsubjectrulesreviews", "subjectaccessreviews", "subjectrulesreviews", "podsecuritypolicyreviews", "podsecuritypolicysubjectreviews", "podsecuritypolicyselfsubjectreviews", "tokenreviews" ], u = function(e) {
var t = {};
return _.each(e, function(e) {
_.each(e.apiGroups, function(n) {
t[n] || (t[n] = {}), _.each(e.resources, function(r) {
t[n][r] = e.verbs;
});
});
}), t;
}, d = function(e) {
return "projectrequests" !== e && !_.includes(e, "/") && !_.includes(l, e);
}, p = function(e) {
return _.some(e, function(e) {
return _.some(e.resources, function(t) {
return d(t) && !_.isEmpty(_.intersection(e.verbs, [ "*", "create", "update" ]));
});
});
}, f = {}, g = function(e) {
return _.get(s.get(e || a), [ "rules" ]);
}, m = function(e, t, n, r) {
var o = e[n];
if (!o) return !1;
var i = o[r];
return !!i && (_.includes(i, t) || _.includes(i, "*"));
};
return {
checkResource: d,
getProjectRules: function(t, r) {
var l = e.defer();
a = t;
var d = s.get(t);
if (!d || d.forceRefresh || r) if (o.apiInfo("selfsubjectrulesreviews")) {
if (f[t]) return f[t];
n.log("AuthorizationService, loading user rules for " + t + " project"), f[t] = l.promise;
var g = {
kind: "SelfSubjectRulesReview",
apiVersion: "v1"
};
i.create("selfsubjectrulesreviews", null, g, {
namespace: t
}).then(function(e) {
var n = u(e.status.rules), r = p(e.status.rules);
s.put(t, {
rules: n,
canAddToProject: r,
forceRefresh: !1,
cacheTimestamp: _.now()
}), l.resolve();
}, function() {
c = !0, l.resolve();
}).finally(function() {
delete f[t];
});
} else n.log("AuthorizationService, resource 'selfsubjectrulesreviews' is not part of APIserver. Switching into permissive mode."), c = !0, l.resolve(); else n.log("AuthorizationService, using cached rules for " + t + " project"), _.now() - d.cacheTimestamp >= 6e5 && (d.forceRefresh = !0), l.resolve();
return l.promise;
},
canI: function(e, t, n) {
if (c) return !0;
if (!e) return !1;
var r = o.toResourceGroupVersion(e), i = g(n || a);
return !!i && (m(i, t, r.group, r.resource) || m(i, t, "*", "*") || m(i, t, r.group, "*") || m(i, t, "*", r.resource));
},
canIAddToProject: function(e) {
return !!c || !!_.get(s.get(e || a), [ "canAddToProject" ]);
},
getRulesForProject: g
};
} ]), angular.module("openshiftCommonServices").factory("base64util", function() {
return {
pad: function(e) {
if (!e) return "";
switch (e.length % 4) {
case 1:
return e + "===";

case 2:
return e + "==";

case 3:
return e + "=";

default:
return e;
}
}
};
}), angular.module("openshiftCommonServices").service("BindingService", [ "$filter", "$q", "APIService", "AuthService", "DataService", "DNS1123_SUBDOMAIN_VALIDATION", function(e, t, n, r, o, i) {
var a = n.getPreferredVersion("servicebindings"), s = n.getPreferredVersion("secrets"), c = e("generateName"), l = function(e) {
var t = _.truncate(e, {
length: i.maxlength - 5 - 1,
omission: ""
});
return c(t, 5);
}, u = function(e, t, n) {
var r = {
apiVersion: "v1",
kind: "Secret",
metadata: {
name: e,
ownerReferences: [ {
apiVersion: n.apiVersion,
kind: n.kind,
name: n.metadata.name,
uid: n.metadata.uid,
controller: !1,
blockOwnerDeletion: !1
} ]
},
type: "Opaque",
stringData: {}
};
return r.stringData.parameters = JSON.stringify(t), r;
}, d = function(e, t, n) {
var r = e.metadata.name, o = l(e.metadata.name + "-credentials-"), i = {
kind: "ServiceBinding",
apiVersion: "servicecatalog.k8s.io/v1beta1",
metadata: {
generateName: r + "-"
},
spec: {
instanceRef: {
name: r
},
secretName: o
}
};
n && (i.spec.parametersFrom = [ {
secretKeyRef: {
name: n,
key: "parameters"
}
} ]);
var a = _.get(t, "spec.selector");
return a && (a.matchLabels || a.matchExpressions || (a = {
matchLabels: a
}), i.spec.alphaPodPresetTemplate = {
name: o,
selector: a
}), i;
}, p = function(t, n, r) {
if (!t || !n || !r) return !1;
if (_.get(t, "metadata.deletionTimestamp")) return !1;
if (e("isServiceInstanceFailed")(t, "Failed")) return !1;
var o = _.get(r, "spec.bindable");
return !0 === o || !1 !== o && n.spec.bindable;
}, f = function(e) {
var t = {};
return _.each(e, function(e) {
var n = _.get(e, "spec.alphaPodPresetTemplate.selector");
n && (t[e.metadata.name] = new LabelSelector(n));
}), t;
};
return {
bindingResource: a,
getServiceClassForInstance: function(e, t) {
if (!t) return null;
var n = _.get(e, "spec.clusterServiceClassRef.name");
return n ? t[n] : null;
},
makeParametersSecret: u,
generateSecretName: l,
bindService: function(e, t, n, r) {
var i;
_.isEmpty(r) || (i = l(e.metadata.name + "-bind-parameters-"));
var c = d(e, t, i), p = {
namespace: e.metadata.namespace
}, f = o.create(a, null, c, p);
return i ? f.then(function(e) {
var t = u(i, r, e);
return o.create(s, null, t, p).then(function() {
return e;
});
}) : f;
},
isServiceBindable: p,
getPodPresetSelectorsForBindings: f,
getBindingsForResource: function(e, t) {
if ("ServiceInstance" === _.get(t, "kind")) return _.filter(e, [ "spec.instanceRef.name", _.get(t, "metadata.name") ]);
var n = f(e), r = new LabelSelector(_.get(t, "spec.selector")), o = [];
return _.each(n, function(t, n) {
t.covers(r) && o.push(e[n]);
}), o;
},
filterBindableServiceInstances: function(e, t, n) {
return e && t && n ? _.filter(e, function(e) {
var r = _.get(e, "spec.clusterServiceClassRef.name"), o = _.get(e, "spec.clusterServicePlanRef.name");
return p(e, t[r], n[o]);
}) : null;
},
sortServiceInstances: function(e, t) {
return _.sortBy(e, [ function(e) {
var n = _.get(e, "spec.clusterServiceClassRef.name");
return _.get(t, [ n, "spec", "externalMetadata", "displayName" ]) || e.spec.clusterServiceClassExternalName;
}, "metadata.name" ]);
}
};
} ]), angular.module("openshiftCommonServices").factory("Constants", function() {
var e = _.clone(window.OPENSHIFT_CONSTANTS || {}), t = _.clone(window.OPENSHIFT_VERSION || {});
return e.VERSION = t, e;
}), angular.module("openshiftCommonServices").factory("DataService", [ "$cacheFactory", "$http", "$ws", "$rootScope", "$q", "API_CFG", "APIService", "Logger", "$timeout", "base64", "base64util", function(e, t, n, r, o, i, a, s, c, l, u) {
function d(e) {
this._data = {}, this._objectsByAttribute(e, "metadata.name", this._data);
}
function p(e, t, n, r) {
for (var o = t.split("."), i = e, a = 0; a < o.length; a++) if (void 0 === (i = i[o[a]])) return;
if ($.isArray(i)) ; else if ($.isPlainObject(i)) for (var s in i) {
var c = i[s];
n[s] || (n[s] = {}), "DELETED" === r ? delete n[s][c] : n[s][c] = e;
} else "DELETED" === r ? delete n[i] : n[i] = e;
}
function f() {
this._listDeferredMap = {}, this._watchCallbacksMap = {}, this._watchObjectCallbacksMap = {}, this._watchOperationMap = {}, this._listOperationMap = {}, this._resourceVersionMap = {}, this._dataCache = e("dataCache", {
number: 25
}), this._immutableDataCache = e("immutableDataCache", {
number: 50
}), this._watchOptionsMap = {}, this._watchWebsocketsMap = {}, this._watchPollTimeoutsMap = {}, this._websocketEventsMap = {};
var t = this;
r.$on("$routeChangeStart", function(e, n, r) {
t._websocketEventsMap = {};
});
}
function g(e) {
return e.length >= S && Date.now() - e[0].time < 3e4;
}
function m(e) {
if (e.length < 5) return !1;
for (var t = e.length - 5; t < e.length; t++) if ("close" !== e[t].type) return !1;
return !0;
}
d.prototype.by = function(e) {
if ("metadata.name" === e) return this._data;
var t = {};
for (var n in this._data) p(this._data[n], e, t, null);
return t;
}, d.prototype.update = function(e, t) {
p(e, "metadata.name", this._data, t);
}, d.prototype._objectsByAttribute = function(e, t, n, r) {
angular.forEach(e, function(e, o) {
p(e, t, n, r ? r[o] : null);
});
};
var h = [], v = _.debounce(function() {
if (h.length) {
var e = {
type: "error",
message: "An error occurred connecting to the server.",
details: h.join("\n"),
links: [ {
label: "Refresh",
onClick: function() {
window.location.reload();
}
} ]
};
r.$emit("NotificationsService.addNotification", e), h = [];
}
}, 300, {
maxWait: 1e3
}), b = function(e, t) {
t && (e += " (status " + t + ")"), h.push(e), v();
}, y = function(e, t) {
var n;
return n = e ? "Unknown resource: " + e.toString() : "Internal error: API resource not specified.", _.get(t, "errorNotification", !0) && b(n), o.reject({
data: {
message: n
}
});
};
f.prototype.list = function(e, t, n, r) {
e = a.toResourceGroupVersion(e);
var o = this._uniqueKey(e, null, t, r), i = this._listDeferred(o);
return n && i.promise.then(n), this._isCached(o) ? i.resolve(this._data(o)) : this._listInFlight(o) || this._startListOp(e, t, r), i.promise;
}, f.prototype.delete = function(e, n, r, i) {
e = a.toResourceGroupVersion(e), i = i || {};
var s = o.defer(), c = this, l = {}, u = {
kind: "DeleteOptions",
apiVersion: "v1"
};
_.has(i, "propagationPolicy") ? u.propagationPolicy = i.propagationPolicy : u.propagationPolicy = "Foreground";
l = {
"Content-Type": "application/json"
};
return _.has(i, "gracePeriodSeconds") && (u.gracePeriodSeconds = i.gracePeriodSeconds), this._getNamespace(e, r, i).then(function(o) {
var a = c._urlForResource(e, n, r, !1, o);
if (!a) return y(e, i);
t(angular.extend({
method: "DELETE",
auth: {},
data: u,
headers: l,
url: a
}, i.http || {})).success(function(e, t, n, r, o) {
s.resolve(e);
}).error(function(e, t, n, r) {
s.reject({
data: e,
status: t,
headers: n,
config: r
});
});
}), s.promise;
}, f.prototype.update = function(e, n, r, i, s) {
e = a.deriveTargetResource(e, r), s = s || {};
var c = o.defer(), l = this;
return this._getNamespace(e, i, s).then(function(o) {
var a = l._urlForResource(e, n, i, !1, o);
if (!a) return y(e, s);
t(angular.extend({
method: "PUT",
auth: {},
data: r,
url: a
}, s.http || {})).success(function(e, t, n, r, o) {
c.resolve(e);
}).error(function(e, t, n, r) {
c.reject({
data: e,
status: t,
headers: n,
config: r
});
});
}), c.promise;
}, f.prototype.create = function(e, n, r, i, s) {
e = a.deriveTargetResource(e, r), s = s || {};
var c = o.defer(), l = this;
return this._getNamespace(e, i, s).then(function(o) {
var a = l._urlForResource(e, n, i, !1, o);
if (!a) return y(e, s);
t(angular.extend({
method: "POST",
auth: {},
data: r,
url: a
}, s.http || {})).success(function(e, t, n, r, o) {
c.resolve(e);
}).error(function(e, t, n, r) {
c.reject({
data: e,
status: t,
headers: n,
config: r
});
});
}), c.promise;
}, f.prototype.batch = function(e, t, n, r) {
function i() {
0 === d && s.resolve({
success: c,
failure: l
});
}
var s = o.defer(), c = [], l = [], u = this, d = e.length;
return n = n || "create", _.each(e, function(e) {
var o = a.objectToResourceGroupVersion(e);
if (!o) return l.push({
object: e,
data: {
message: a.invalidObjectKindOrVersion(e)
}
}), d--, void i();
if (!a.apiInfo(o)) return l.push({
object: e,
data: {
message: a.unsupportedObjectKindOrVersion(e)
}
}), d--, void i();
var p = function(t) {
t.object = e, c.push(t), d--, i();
}, f = function(t) {
t.object = e, l.push(t), d--, i();
};
switch (n) {
case "create":
u.create(o, null, e, t, r).then(p, f);
break;

case "update":
u.update(o, e.metadata.name, e, t, r).then(p, f);
break;

default:
return s.reject({
data: "Invalid '" + n + "'  action.",
status: 400,
headers: function() {
return null;
},
config: {},
object: e
});
}
}), s.promise;
}, f.prototype.get = function(e, n, r, i) {
e = a.toResourceGroupVersion(e), i = i || {};
var s = this._uniqueKey(e, n, r, i);
i.force;
delete i.force;
var l = o.defer(), u = this._immutableData(s);
if (this._hasImmutable(e, u, n)) c(function() {
l.resolve(u.by("metadata.name")[n]);
}, 0); else {
var d = this;
this._getNamespace(e, r, i).then(function(o) {
var a = d._urlForResource(e, n, r, !1, o);
if (!a) return y(e, i);
t(angular.extend({
method: "GET",
auth: {},
url: a
}, i.http || {})).success(function(t, n, r, o, i) {
d._isImmutable(e) && (u ? u.update(t, "ADDED") : d._immutableData(s, [ t ])), l.resolve(t);
}).error(function(t, r, o, a) {
!1 !== i.errorNotification && b("Failed to get " + e + "/" + n, r), l.reject({
data: t,
status: r,
headers: o,
config: a
});
});
});
}
return l.promise;
}, f.prototype.createStream = function(e, t, r, o, i) {
var c = this;
e = a.toResourceGroupVersion(e);
var d, p = i ? "binary.k8s.io" : "base64.binary.k8s.io", f = {}, g = {}, m = {}, h = {}, v = function() {
return c._getNamespace(e, r, {}).then(function(a) {
var d = c._urlForResource(e, t, r, !0, _.extend(a, o));
if (!d) return y(e, o);
var v = 0;
return n({
url: d,
auth: {},
onopen: function(e) {
_.each(f, function(t) {
t(e);
});
},
onmessage: function(e) {
if (_.isString(e.data)) {
var t;
i || (t = l.decode(u.pad(e.data)), v += t.length), _.each(g, function(n) {
i ? n(e.data) : n(t, e.data, v);
});
} else s.log("log stream response is not a string", e.data);
},
onclose: function(e) {
_.each(m, function(t) {
t(e);
});
},
onerror: function(e) {
_.each(h, function(t) {
t(e);
});
},
protocols: p
}).then(function(e) {
return s.log("Streaming pod log", e), e;
});
});
};
return {
onOpen: function(e) {
if (_.isFunction(e)) {
var t = _.uniqueId("stream_");
return f[t] = e, t;
}
},
onMessage: function(e) {
if (_.isFunction(e)) {
var t = _.uniqueId("stream_");
return g[t] = e, t;
}
},
onClose: function(e) {
if (_.isFunction(e)) {
var t = _.uniqueId("stream_");
return m[t] = e, t;
}
},
onError: function(e) {
if (_.isFunction(e)) {
var t = _.uniqueId("stream_");
return h[t] = e, t;
}
},
remove: function(e) {
f[e] && delete f[e], g[e] && delete g[e], m[e] && delete m[e], h[e] && delete h[e];
},
start: function() {
return d = v();
},
stop: function() {
d.then(function(e) {
e.close();
});
}
};
}, f.prototype.watch = function(e, t, n, r) {
e = a.toResourceGroupVersion(e);
var o = !(r = r || {}).skipDigest, i = this._uniqueKey(e, null, t, r);
if (n) this._watchCallbacks(i).add(n); else if (!this._watchCallbacks(i).has()) return {};
var s = this._watchOptions(i);
if (s) {
if (!!s.poll != !!r.poll) throw "A watch already exists for " + e + " with a different polling option.";
} else this._watchOptions(i, r);
var l = this;
if (this._isCached(i)) n && c(function() {
n(l._data(i));
}, 0, o); else {
if (n) {
var u = this._resourceVersion(i);
this._data(i) && c(function() {
u === l._resourceVersion(i) && n(l._data(i));
}, 0, o);
}
this._listInFlight(i) || this._startListOp(e, t, r);
}
return {
resource: e,
context: t,
callback: n,
opts: r
};
}, f.prototype.watchObject = function(e, t, n, r, o) {
e = a.toResourceGroupVersion(e), o = o || {};
var i, s = this._uniqueKey(e, t, n, o);
if (s && r) {
this._watchObjectCallbacks(s).add(r);
var c = this;
i = function(e, n, r) {
if (r && r.metadata.name === t) c._watchObjectCallbacks(s).fire(r, n); else if (!r) {
var o = e.by("metadata.name");
o[t] && c._watchObjectCallbacks(s).fire(o[t]);
}
};
} else if (!this._watchObjectCallbacks(s).has()) return {};
var l = this.watch(e, n, i, o);
return l.objectCallback = r, l.objectName = t, l;
}, f.prototype.unwatch = function(e) {
var t = e.resource, n = e.objectName, r = e.context, o = e.callback, i = e.objectCallback, a = e.opts, s = this._uniqueKey(t, null, r, a);
if (i && n) {
var c = this._uniqueKey(t, n, r, a);
this._watchObjectCallbacks(c).remove(i);
}
var l = this._watchCallbacks(s);
if (o && l.remove(o), !l.has()) {
if (a && a.poll) clearTimeout(this._watchPollTimeouts(s)), this._watchPollTimeouts(s, null); else if (this._watchWebsockets(s)) {
var u = this._watchWebsockets(s);
u.shouldClose = !0, u.close(), this._watchWebsockets(s, null);
}
this._watchInFlight(s, !1), this._watchOptions(s, null);
}
}, f.prototype.unwatchAll = function(e) {
for (var t = 0; t < e.length; t++) this.unwatch(e[t]);
}, f.prototype._watchCallbacks = function(e) {
return this._watchCallbacksMap[e] || (this._watchCallbacksMap[e] = $.Callbacks()), this._watchCallbacksMap[e];
}, f.prototype._watchObjectCallbacks = function(e) {
return this._watchObjectCallbacksMap[e] || (this._watchObjectCallbacksMap[e] = $.Callbacks()), this._watchObjectCallbacksMap[e];
}, f.prototype._listDeferred = function(e) {
return this._listDeferredMap[e] || (this._listDeferredMap[e] = o.defer()), this._listDeferredMap[e];
}, f.prototype._watchInFlight = function(e, t) {
if (!t && !1 !== t) return this._watchOperationMap[e];
this._watchOperationMap[e] = t;
}, f.prototype._listInFlight = function(e, t) {
if (!t && !1 !== t) return this._listOperationMap[e];
this._listOperationMap[e] = t;
}, f.prototype._resourceVersion = function(e, t) {
if (!t) return this._resourceVersionMap[e];
this._resourceVersionMap[e] = t;
}, f.prototype._data = function(e, t) {
return t ? this._dataCache.put(e, new d(t)) : this._dataCache.get(e);
}, f.prototype._immutableData = function(e, t) {
return t ? this._immutableDataCache.put(e, new d(t)) : this._immutableDataCache.get(e);
}, f.prototype._isCached = function(e) {
return this._watchInFlight(e) && this._resourceVersion(e) && !!this._data(e);
}, f.prototype._watchOptions = function(e, t) {
if (void 0 === t) return this._watchOptionsMap[e];
this._watchOptionsMap[e] = t;
}, f.prototype._watchPollTimeouts = function(e, t) {
if (!t) return this._watchPollTimeoutsMap[e];
this._watchPollTimeoutsMap[e] = t;
}, f.prototype._watchWebsockets = function(e, t) {
if (!t) return this._watchWebsocketsMap[e];
this._watchWebsocketsMap[e] = t;
};
var S = 10;
f.prototype._addWebsocketEvent = function(e, t) {
var n = this._websocketEventsMap[e];
for (n || (n = this._websocketEventsMap[e] = []), n.push({
type: t,
time: Date.now()
}); n.length > S; ) n.shift();
}, f.prototype._isTooManyWebsocketRetries = function(e) {
var t = this._websocketEventsMap[e];
return !!t && (g(t) ? (s.log("Too many websocket open or close events for resource/context in a short period", e, t), !0) : !!m(t) && (s.log("Too many consecutive websocket close events for resource/context", e, t), !0));
};
var w = function(e) {
var t = _.keysIn(_.pick(e, [ "fieldSelector", "labelSelector" ])).sort();
return _.reduce(t, function(n, r, o) {
return n + r + "=" + encodeURIComponent(e[r]) + (o < t.length - 1 ? "&" : "");
}, "?");
};
f.prototype._uniqueKey = function(e, t, n, r) {
var o, i = n && n.namespace || _.get(n, "project.metadata.name") || n.projectName, a = _.get(r, "http.params"), s = this._urlForResource(e, t, n, null, angular.extend({}, {}, {
namespace: i
}));
return o = s ? s.toString() : e || "<unknown>", o += w(a || {}), _.get(r, "partialObjectMetadataList") ? o + "#application/json;as=PartialObjectMetadataList;v=v1beta1;g=meta.k8s.io,application/json" : o;
}, f.prototype._startListOp = function(e, n, r) {
r = r || {};
var o = _.get(r, "http.params") || {}, i = this._uniqueKey(e, null, n, r);
this._listInFlight(i, !0);
var a = {};
r.partialObjectMetadataList && (a.Accept = "application/json;as=PartialObjectMetadataList;v=v1beta1;g=meta.k8s.io,application/json");
var s, c = this;
if (n.projectPromise && !e.equals("projects")) n.projectPromise.done(function(l) {
if (!(s = c._urlForResource(e, null, n, !1, _.assign({}, o, {
namespace: l.metadata.name
})))) return y(e, r);
t(angular.extend({
method: "GET",
auth: {},
headers: a,
url: s
}, r.http || {})).success(function(t, o, a, s, l) {
c._listOpComplete(i, e, n, r, t);
}).error(function(t, n, o, a) {
c._listInFlight(i, !1);
var s = c._listDeferred(i);
delete c._listDeferredMap[i], s.reject({
data: t,
status: n,
headers: o,
config: a
}), _.get(r, "errorNotification", !0) && b("Failed to list " + e, n);
});
}); else {
if (!(s = this._urlForResource(e, null, n, !1, o))) return y(e, r);
t({
method: "GET",
auth: {},
headers: a,
url: s
}).success(function(t, o, a, s, l) {
c._listOpComplete(i, e, n, r, t);
}).error(function(t, n, o, a) {
c._listInFlight(i, !1);
var s = c._listDeferred(i);
delete c._listDeferredMap[i], s.reject({
data: t,
status: n,
headers: o,
config: a
}), _.get(r, "errorNotification", !0) && b("Failed to list " + e, n);
});
}
}, f.prototype._listOpComplete = function(e, t, n, r, o) {
o.items || console.warn("List request for " + t + " returned a null items array.  This is an invalid API response.");
var i = o.items || [];
o.kind && o.kind.indexOf("List") === o.kind.length - 4 && angular.forEach(i, function(e) {
e.kind || (e.kind = o.kind.slice(0, -4)), e.apiVersion || (e.apiVersion = o.apiVersion);
}), this._listInFlight(e, !1);
var a = this._listDeferred(e);
delete this._listDeferredMap[e];
var s = _.get(o, "resourceVersion") || _.get(o, "metadata.resourceVersion");
if (this._resourceVersion(e, s), this._data(e, i), a.resolve(this._data(e)), this._watchCallbacks(e).fire(this._data(e)), this._watchCallbacks(e).has()) {
var c = this._watchOptions(e) || {};
c.poll ? (this._watchInFlight(e, !0), this._watchPollTimeouts(e, setTimeout($.proxy(this, "_startListOp", t, n), c.pollInterval || 5e3))) : this._watchInFlight(e) || this._startWatchOp(e, t, n, r, this._resourceVersion(e));
}
}, f.prototype._startWatchOp = function(e, t, r, o, i) {
if (this._watchInFlight(e, !0), n.available()) {
var a = this, c = _.get(o, "http.params") || {};
c.watch = !0, i && (c.resourceVersion = i), r.projectPromise && !t.equals("projects") ? r.projectPromise.done(function(i) {
c.namespace = i.metadata.name, n({
method: "WATCH",
url: a._urlForResource(t, null, r, !0, c),
auth: {},
onclose: $.proxy(a, "_watchOpOnClose", t, r, o),
onmessage: $.proxy(a, "_watchOpOnMessage", t, r, o),
onopen: $.proxy(a, "_watchOpOnOpen", t, r, o)
}).then(function(t) {
s.log("Watching", t), a._watchWebsockets(e, t);
});
}) : n({
method: "WATCH",
url: a._urlForResource(t, null, r, !0, c),
auth: {},
onclose: $.proxy(a, "_watchOpOnClose", t, r, o),
onmessage: $.proxy(a, "_watchOpOnMessage", t, r, o),
onopen: $.proxy(a, "_watchOpOnOpen", t, r, o)
}).then(function(t) {
s.log("Watching", t), a._watchWebsockets(e, t);
});
}
}, f.prototype._watchOpOnOpen = function(e, t, n, r) {
s.log("Websocket opened for resource/context", e, t);
var o = this._uniqueKey(e, null, t, n);
this._addWebsocketEvent(o, "open");
}, f.prototype._watchOpOnMessage = function(e, t, n, r) {
var o = this._uniqueKey(e, null, t, n), i = !(n = n || {}).skipDigest;
try {
var a = $.parseJSON(r.data);
if ("ERROR" == a.type) return s.log("Watch window expired for resource/context", e, t), void (r.target && (r.target.shouldRelist = !0));
"DELETED" === a.type && a.object && a.object.metadata && !a.object.metadata.deletionTimestamp && (a.object.metadata.deletionTimestamp = new Date().toISOString()), a.object && this._resourceVersion(o, a.object.resourceVersion || a.object.metadata.resourceVersion), this._data(o).update(a.object, a.type);
var l = this;
c(function() {
l._watchCallbacks(o).fire(l._data(o), a.type, a.object);
}, 0, i);
} catch (t) {
s.error("Error processing message", e, r.data);
}
}, f.prototype._watchOpOnClose = function(e, t, n, o) {
var i = o.target, a = this._uniqueKey(e, null, t, n);
if (i) {
var c = this._watchWebsockets(a);
if (c) if (i === c) if (this._watchInFlight(a, !1), i.shouldClose) s.log("Skipping reopen, eventWS was explicitly closed", i); else if (o.wasClean) s.log("Skipping reopen, clean close", o); else if (this._watchCallbacks(a).has()) if (this._isTooManyWebsocketRetries(a)) _.get(n, "errorNotification", !0) && r.$emit("NotificationsService.addNotification", {
id: "websocket_retry_halted",
type: "error",
message: "Server connection interrupted.",
links: [ {
label: "Refresh",
onClick: function() {
window.location.reload();
}
} ]
}); else if (this._addWebsocketEvent(a, "close"), i.shouldRelist) {
s.log("Relisting for resource/context", e, t);
var l = this;
setTimeout(function() {
l.watch(e, t);
}, 2e3);
} else s.log("Rewatching for resource/context", e, t), this._watchInFlight(a, !0), setTimeout($.proxy(this, "_startWatchOp", a, e, t, n, this._resourceVersion(a)), 2e3); else s.log("Skipping reopen, no listeners registered for resource/context", e, t); else s.log("Skipping reopen, eventWS does not match registeredWS", i, c); else s.log("Skipping reopen, no registeredWS for resource/context", e, t);
} else s.log("Skipping reopen, no eventWS in event", o);
};
f.prototype._urlForResource = function(e, t, n, r, o) {
var i = a.apiInfo(e);
if (!i) return s.error("_urlForResource called with unknown resource", e, arguments), null;
var c, l = i.protocol || window.location.protocol;
if (o = o || {}, c = r ? "http:" === l ? "ws" : "wss" : "http:" === l ? "http" : "https", n && n.namespace && !o.namespace && (o.namespace = n.namespace), i.namespaced && !o.namespace) return s.error("_urlForResource called for a namespaced resource but no namespace provided", e, arguments), null;
var u = i.namespaced, d = null;
u && (d = o.namespace, delete (o = angular.copy(o)).namespace);
var p, f = {
protocol: c,
hostPort: i.hostPort,
prefix: i.prefix,
group: i.group,
version: i.version,
resource: e.primaryResource(),
subresource: e.subresources(),
name: t,
namespace: d,
q: o
};
return p = t ? u ? "{protocol}://{+hostPort}{+prefix}{/group}/{version}/namespaces/{namespace}/{resource}/{name}{/subresource*}{?q*}" : "{protocol}://{+hostPort}{+prefix}{/group}/{version}/{resource}/{name}{/subresource*}{?q*}" : u ? "{protocol}://{+hostPort}{+prefix}{/group}/{version}/namespaces/{namespace}/{resource}{?q*}" : "{protocol}://{+hostPort}{+prefix}{/group}/{version}/{resource}{?q*}", URI.expand(p, f).toString();
}, f.prototype.url = function(e) {
if (e && e.resource) {
var t = angular.copy(e);
delete t.resource, delete t.group, delete t.version, delete t.name, delete t.isWebsocket;
var n = a.toResourceGroupVersion({
resource: e.resource,
group: e.group,
version: e.version
});
return this._urlForResource(n, e.name, null, !!e.isWebsocket, t);
}
return null;
}, f.prototype.openshiftAPIBaseUrl = function() {
var e = "http:" === window.location.protocol ? "http" : "https", t = i.openshift.hostPort;
return new URI({
protocol: e,
hostname: t
}).toString();
}, f.prototype._getAPIServerVersion = function(e) {
var n = "http:" === window.location.protocol ? "http" : "https", r = new URI({
protocol: n,
hostname: i.k8s.hostPort,
path: e
}).toString();
return t.get(r, {
headers: {
Accept: "application/json"
}
});
}, f.prototype.getKubernetesMasterVersion = function() {
return this._getAPIServerVersion("/version");
}, f.prototype.getOpenShiftMasterVersion = function() {
return this._getAPIServerVersion("/version/openshift");
}, f.prototype.createData = function(e) {
return new d(e);
};
var k = {
imagestreamimages: !0
};
return f.prototype._isImmutable = function(e) {
return !!k[e.resource];
}, f.prototype._hasImmutable = function(e, t, n) {
return this._isImmutable(e) && t && t.by("metadata.name")[n];
}, f.prototype._getNamespace = function(e, t, n) {
var r = o.defer();
return n.namespace ? r.resolve({
namespace: n.namespace
}) : t.projectPromise && !e.equals("projects") ? t.projectPromise.done(function(e) {
r.resolve({
namespace: e.metadata.name
});
}) : r.resolve(null), r.promise;
}, new f();
} ]), angular.module("openshiftCommonServices").provider("DeleteTokenLogoutService", function() {
this.$get = [ "$q", "$injector", "Logger", function(e, t, n) {
var r = n.get("auth");
return {
logout: function(n, o) {
if (r.log("DeleteTokenLogoutService.logout()", n, o), !o) return r.log("DeleteTokenLogoutService, no token, returning immediately"), e.when({});
var i = t.get("APIService"), a = t.get("DataService"), s = i.getPreferredVersion("oauthaccesstokens"), c = {
http: {
auth: {
token: o,
triggerLogin: !1
}
}
};
return a.delete(s, o, {}, c);
}
};
} ];
}), angular.module("openshiftCommonServices").service("KeywordService", [ "$filter", function(e) {
var t = e("displayName");
return {
filterForKeywords: function(e, t, n) {
var r = e;
return _.isEmpty(n) ? r : (angular.forEach(n, function(e) {
r = _.filter(r, function(n) {
var r;
for (r = 0; r < t.length; r++) {
var o = _.get(n, t[r]);
if (o && e.test(o)) return !0;
}
return !1;
});
}), r);
},
weightedSearch: function(e, n, r) {
if (_.isEmpty(r)) return [];
var o = [];
_.each(e, function(e) {
var t = 0;
_.each(r, function(r) {
var o = !1;
if (_.each(n, function(n) {
var i = _.get(e, n.path);
i && r.test(i) && (t += n.weight, o = !0);
}), !o) return t = 0, !1;
}), t > 0 && o.push({
object: e,
score: t
});
});
var i = _.orderBy(o, [ "score", t ], [ "desc", "asc" ]);
return _.map(i, "object");
},
generateKeywords: function(e) {
if (!e) return [];
var t = _.uniq(e.match(/\S+/g));
return t.sort(function(e, t) {
return t.length - e.length;
}), _.map(t, function(e) {
return new RegExp(_.escapeRegExp(e), "i");
});
}
};
} ]), angular.module("openshiftCommonServices").provider("Logger", function() {
this.$get = function() {
var e = Logger.get("OpenShift"), t = {
get: function(e) {
var t = Logger.get("OpenShift/" + e), n = "OFF";
return localStorage && (n = localStorage["OpenShiftLogLevel." + e] || n), t.setLevel(Logger[n]), t;
},
log: function() {
e.log.apply(e, arguments);
},
info: function() {
e.info.apply(e, arguments);
},
debug: function() {
e.debug.apply(e, arguments);
},
warn: function() {
e.warn.apply(e, arguments);
},
error: function() {
e.error.apply(e, arguments);
}
}, n = "ERROR";
return localStorage && (n = localStorage["OpenShiftLogLevel.main"] || n), e.setLevel(Logger[n]), t;
};
}), angular.module("openshiftCommonServices").provider("MemoryUserStore", function() {
this.$get = [ "Logger", function(e) {
var t = e.get("auth"), n = null, r = null;
return {
available: function() {
return !0;
},
getUser: function() {
return t.log("MemoryUserStore.getUser", n), n;
},
setUser: function(e, r) {
t.log("MemoryUserStore.setUser", e), n = e;
},
getToken: function() {
return t.log("MemoryUserStore.getToken", r), r;
},
setToken: function(e, n) {
t.log("MemoryUserStore.setToken", e), r = e;
}
};
} ];
}).provider("SessionStorageUserStore", function() {
this.$get = [ "Logger", function(e) {
var t = e.get("auth"), n = "SessionStorageUserStore.user", r = "SessionStorageUserStore.token";
return {
available: function() {
try {
var e = String(new Date().getTime());
sessionStorage["SessionStorageUserStore.test"] = e;
var t = sessionStorage["SessionStorageUserStore.test"];
return sessionStorage.removeItem("SessionStorageUserStore.test"), e === t;
} catch (e) {
return !1;
}
},
getUser: function() {
try {
var e = JSON.parse(sessionStorage[n]);
return t.log("SessionStorageUserStore.getUser", e), e;
} catch (e) {
return t.error("SessionStorageUserStore.getUser", e), null;
}
},
setUser: function(e, r) {
e ? (t.log("SessionStorageUserStore.setUser", e), sessionStorage[n] = JSON.stringify(e)) : (t.log("SessionStorageUserStore.setUser", e, "deleting"), sessionStorage.removeItem(n));
},
getToken: function() {
try {
var e = sessionStorage[r];
return t.log("SessionStorageUserStore.getToken", e), e;
} catch (e) {
return t.error("SessionStorageUserStore.getToken", e), null;
}
},
setToken: function(e, n) {
e ? (t.log("SessionStorageUserStore.setToken", e), sessionStorage[r] = e) : (t.log("SessionStorageUserStore.setToken", e, "deleting"), sessionStorage.removeItem(r));
}
};
} ];
}).provider("LocalStorageUserStore", function() {
this.$get = [ "Logger", function(e) {
var t = e.get("auth"), n = "LocalStorageUserStore.user", r = "LocalStorageUserStore.token", o = function(e) {
return e + ".ttl";
}, i = function(e, n) {
if (n) {
var r = new Date().getTime() + 1e3 * n;
localStorage[o(e)] = r, t.log("LocalStorageUserStore.setTTL", e, n, new Date(r).toString());
} else localStorage.removeItem(o(e)), t.log("LocalStorageUserStore.setTTL deleting", e);
}, a = function(e) {
var n = localStorage[o(e)];
if (!n) return !1;
var r = parseInt(n) < new Date().getTime();
return t.log("LocalStorageUserStore.isTTLExpired", e, r), r;
};
return {
available: function() {
try {
var e = String(new Date().getTime());
localStorage["LocalStorageUserStore.test"] = e;
var t = localStorage["LocalStorageUserStore.test"];
return localStorage.removeItem("LocalStorageUserStore.test"), e === t;
} catch (e) {
return !1;
}
},
getUser: function() {
try {
if (a(n)) return t.log("LocalStorageUserStore.getUser expired"), localStorage.removeItem(n), i(n, null), null;
var e = JSON.parse(localStorage[n]);
return t.log("LocalStorageUserStore.getUser", e), e;
} catch (e) {
return t.error("LocalStorageUserStore.getUser", e), null;
}
},
setUser: function(e, r) {
e ? (t.log("LocalStorageUserStore.setUser", e, r), localStorage[n] = JSON.stringify(e), i(n, r)) : (t.log("LocalStorageUserStore.setUser", e, "deleting"), localStorage.removeItem(n), i(n, null));
},
getToken: function() {
try {
if (a(r)) return t.log("LocalStorageUserStore.getToken expired"), localStorage.removeItem(r), i(r, null), null;
var e = localStorage[r];
return t.log("LocalStorageUserStore.getToken", e), e;
} catch (e) {
return t.error("LocalStorageUserStore.getToken", e), null;
}
},
setToken: function(e, n) {
e ? (t.log("LocalStorageUserStore.setToken", e, n), localStorage[r] = e, i(r, n)) : (t.log("LocalStorageUserStore.setToken", e, n, "deleting"), localStorage.removeItem(r), i(r, null));
}
};
} ];
}), angular.module("openshiftCommonServices").factory("ProjectsService", [ "$location", "$q", "$rootScope", "APIService", "AuthService", "AuthorizationService", "DataService", "Logger", "RecentlyViewedProjectsService", "annotationNameFilter", function(e, t, n, r, o, i, a, s, c, l) {
var u, d = !1, p = r.getPreferredVersion("projects"), f = r.getPreferredVersion("projectrequests"), g = function() {
s.debug("ProjectsService: clearing project cache"), u = null, d = !1;
};
o.onUserChanged(g), o.onLogout(g);
var m = function(e) {
var t = [ l("description"), l("displayName") ];
return _.each(t, function(t) {
e.metadata.annotations[t] || delete e.metadata.annotations[t];
}), e;
};
return {
get: function(n, r) {
return o.withUser().then(function() {
var o = {
projectPromise: $.Deferred(),
projectName: n,
project: void 0
};
return a.get(p, n, o, {
errorNotification: !1
}).then(function(e) {
return i.getProjectRules(n).then(function() {
return o.project = e, o.projectPromise.resolve(e), c.addProjectUID(e.metadata.uid), u && u.update(e, "MODIFIED"), [ e, o ];
});
}, function(n) {
if (o.projectPromise.reject(n), (403 === n.status || 404 === n.status) && _.get(r, "skipErrorNotFound")) return t.reject({
notFound: !0
});
var i = "The project could not be loaded.", a = "error";
return 403 === n.status ? (i = "The project " + o.projectName + " does not exist or you are not authorized to view it.", a = "access_denied") : 404 === n.status && (i = "The project " + o.projectName + " does not exist.", a = "not_found"), e.url(URI("error").query({
error: a,
error_description: i
}).toString()), t.reject();
});
});
},
list: function(e) {
return u && !e ? (s.debug("ProjectsService: returning cached project data"), t.when(u)) : (s.debug("ProjectsService: listing projects, force refresh", e), a.list(p, {}).then(function(e) {
return u = e, e;
}, function(e) {
return u = a.createData([]), d = !0, t.reject();
}));
},
isProjectListIncomplete: function() {
return d;
},
watch: function(e, t) {
return a.watch(p, e, function(e) {
u = e, t(e);
});
},
update: function(e, t) {
return a.update(p, e, m(t), {
projectName: e
}, {
errorNotification: !1
}).then(function(e) {
return u && u.update(e, "MODIFIED"), e;
});
},
create: function(e, t, n) {
var o = {
apiVersion: r.toAPIVersion(f),
kind: "ProjectRequest",
metadata: {
name: e
},
displayName: t,
description: n
};
return a.create(f, null, o, {}).then(function(e) {
return c.addProjectUID(e.metadata.uid), u && u.update(e, "ADDED"), e;
});
},
canCreate: function() {
return a.get(f, null, {}, {
errorNotification: !1
});
},
delete: function(e) {
return a.delete(p, e.metadata.name, {}).then(function(t) {
return u && u.update(e, "DELETED"), t;
});
}
};
} ]), angular.module("openshiftCommonServices").factory("PromiseUtils", [ "$q", function(e) {
return {
waitForAll: function(t) {
var n = _.size(t);
if (!n) return e.when();
var r = e.defer(), o = 0, i = !1, a = function() {
o < n || (i ? r.reject() : r.resolve());
};
return _.each(t, function(e) {
if (!e) return o++, void a();
e.catch(function() {
i = !0;
}).finally(function() {
o++, a();
});
}), r.promise;
}
};
} ]), angular.module("openshiftCommonServices").service("RecentlyViewedProjectsService", [ "$filter", function(e) {
var t = function() {
var e = localStorage.getItem("openshift/recently-viewed-project-uids");
return e ? JSON.parse(e) : [];
}, n = function(e) {
localStorage.setItem("openshift/recently-viewed-project-uids", JSON.stringify(e));
};
return {
getProjectUIDs: t,
addProjectUID: function(e) {
var r = t();
r.unshift(e), r = _.uniq(r), r = _.take(r, 5), n(r);
},
orderByMostRecentlyViewed: function(n) {
var r = [], o = t();
return _.each(o, function(e) {
var t = _.remove(n, function(t) {
return t.metadata.uid === e;
})[0];
void 0 !== t && r.push(t);
}), n = _.sortBy(n, function(t) {
return e("displayName")(t).toLowerCase();
}), r.concat(n);
},
clear: function() {
localStorage.removeItem("openshift/recently-viewed-project-uids");
},
isRecentlyViewed: function(e) {
return _.includes(t(), e);
}
};
} ]), angular.module("openshiftCommonServices").provider("RedirectLoginService", function() {
var e = "", t = "", n = "", r = "", o = "";
this.OAuthClientID = function(t) {
return t && (e = t), e;
}, this.OAuthAuthorizeURI = function(e) {
return e && (t = e), t;
}, this.OAuthTokenURI = function(e) {
return e && (n = e), n;
}, this.OAuthRedirectURI = function(e) {
return e && (r = e), r;
}, this.OAuthScope = function(e) {
return e && (o = e), o;
}, this.$get = [ "$injector", "$location", "$q", "Logger", "base64", function(i, a, s, c, l) {
var u = c.get("auth"), d = function(e) {
var t;
if (window.crypto && window.Uint32Array) try {
var n = new Uint32Array(e);
window.crypto.getRandomValues(n), t = [];
for (var r = 0; r < e; r++) t.push(n[r]);
} catch (e) {
u.debug("RedirectLoginService.getRandomInts: ", e), t = null;
}
if (!t) {
t = [];
for (var o = 0; o < e; o++) t.push(Math.floor(4294967296 * Math.random()));
}
return t;
}, p = "RedirectLoginService.nonce", f = function(e) {
var t = String(new Date().getTime()) + "-" + d(8).join("");
try {
window.localStorage[p] && window.localStorage[p].length > 10 ? t = window.localStorage[p] : window.localStorage[p] = t;
} catch (e) {
u.log("RedirectLoginService.makeState, localStorage error: ", e);
}
return l.urlencode(JSON.stringify({
then: e,
nonce: t
}));
}, g = function(e) {
var t = {
then: null,
verified: !1
}, n = "";
try {
n = window.localStorage[p], window.localStorage.removeItem(p);
} catch (e) {
u.log("RedirectLoginService.parseState, localStorage error: ", e);
}
try {
var r = e ? JSON.parse(l.urldecode(e)) : {};
r && r.nonce && n && r.nonce === n && (t.verified = !0, t.then = r.then);
} catch (e) {
u.error("RedirectLoginService.parseState, state error: ", e);
}
return u.error("RedirectLoginService.parseState", t), t;
};
return {
login: function() {
if ("" === e) return s.reject({
error: "invalid_request",
error_description: "RedirectLoginServiceProvider.OAuthClientID() not set"
});
if ("" === t) return s.reject({
error: "invalid_request",
error_description: "RedirectLoginServiceProvider.OAuthAuthorizeURI() not set"
});
if ("" === r) return s.reject({
error: "invalid_request",
error_description: "RedirectLoginServiceProvider.OAuthRedirectURI not set"
});
var i = new URI(a.url()).fragment(""), c = {
client_id: e,
response_type: "token",
state: f(i.toString()),
redirect_uri: r
};
o && (c.scope = o), n && (c.response_type = "code");
var l = s.defer(), d = new URI(t);
return d.query(c), u.log("RedirectLoginService.login(), redirecting", d.toString()), window.location.href = d.toString(), l.promise;
},
finish: function() {
var t = i.get("$http"), c = function(e, t) {
return e.error ? (u.log("RedirectLoginService.finish(), error", e.error, e.error_description, e.error_uri), s.reject({
error: e.error,
error_description: e.error_description,
error_uri: e.error_uri
})) : e.access_token ? s.when({
token: e.access_token,
ttl: e.expires_in,
then: t.then,
verified: t.verified
}) : s.reject({
error: "invalid_request",
error_description: "No API token returned"
});
}, l = new URI(a.url()), d = l.query(!0), p = new URI("?" + l.fragment()).query(!0);
if (u.log("RedirectLoginService.finish()", d, p), d.error) return c(d, g(d.state));
if (p.error) return c(p, g(p.state));
if (p.access_token) return c(p, g(p.state));
if (n && d.code) {
var f = g(d.state);
if (!f.verified) return s.reject({
error: "invalid_request",
error_description: "Client state could not be verified"
});
var m = [ "grant_type=authorization_code", "code=" + encodeURIComponent(d.code), "redirect_uri=" + encodeURIComponent(r), "client_id=" + encodeURIComponent(e) ].join("&");
return o && (m += "&scope=" + encodeURIComponent(o)), t({
method: "POST",
url: n,
headers: {
Authorization: "Basic " + window.btoa(e + ":"),
"Content-Type": "application/x-www-form-urlencoded"
},
data: m
}).then(function(e) {
return c(e.data, f);
}, function(e) {
return u.log("RedirectLoginService.finish(), error getting access token", e), c(e.data, f);
});
}
return s.reject({
error: "invalid_request",
error_description: "No API token returned"
});
}
};
} ];
}), angular.module("openshiftCommonServices").service("VersionsService", function() {
var e = function(e, t, n) {
e = e || "", t = t || "";
try {
var r = window.compareVersions(e, t);
return n ? -1 * r : r;
} catch (n) {
return e.localeCompare(t);
}
};
return {
compare: function(t, n) {
return e(t, n, !1);
},
rcompare: function(t, n) {
return e(t, n, !0);
}
};
}), angular.module("openshiftCommonServices").provider("$ws", [ "$httpProvider", function(e) {
this.$get = [ "$q", "$injector", "Logger", function(t, n, r) {
var o = r.get("auth");
o.log("$wsProvider.$get", arguments);
var i = [];
angular.forEach(e.interceptors, function(e) {
angular.isString(e) ? i.unshift(n.get(e)) : i.unshift(n.invoke(e));
});
var a = function(e) {
e.method = angular.uppercase(e.method || "WATCH"), o.log("$ws (pre-intercept)", e.url.toString());
var n = [ function(e) {
o.log("$ws (post-intercept)", e.url.toString());
var t = new WebSocket(e.url, e.protocols);
return e.onclose && (t.onclose = e.onclose), e.onmessage && (t.onmessage = e.onmessage), e.onopen && (t.onopen = e.onopen), e.onerror && (t.onerror = e.onerror), t;
}, void 0 ], r = t.when(e);
for (angular.forEach(i, function(e) {
(e.request || e.requestError) && n.unshift(e.request, e.requestError);
}); n.length; ) {
var a = n.shift(), s = n.shift();
r = r.then(a, s);
}
return r;
};
return a.available = function() {
try {
return !!WebSocket;
} catch (e) {
return !1;
}
}, a;
} ];
} ]), angular.module("openshiftCommonUI").factory("GuidedTourService", function() {
function e() {
$("#guided_tour_backdrop").click(u);
}
function t() {
$("#guided_tour_backdrop").remove(), angular.isFunction(c.onTourEndCB) && c.onTourEndCB();
}
function n() {
_.forEach(c.steps, function(e) {
e.onNextOrig = e.onNext, e.onPrevOrig = e.onPrev, e.onNext = r, e.onPrev = o, e.fixedElement = !0, !angular.isUndefined(e.yOffset) || "right" !== e.placement && "left" !== e.placement || (e.yOffset = -45), e.title = _.isFunction(e.title) ? e.title() : e.title, e.content = _.isFunction(e.content) ? e.content() : e.content, e.target = _.isFunction(e.target) ? e.target() : e.target, e.placement = _.isFunction(e.placement) ? e.placement() : e.placement;
});
}
function r() {
var e = hopscotch.getCurrStepNum() - 1, t = c.steps[e];
t && (t.onNextOrig && t.onNextOrig(), i(e + 1));
}
function o() {
var e = hopscotch.getCurrStepNum() + 1, t = c.steps[e];
t && (t.onPrevOrig && t.onPrevOrig(), i(e - 1));
}
function i(e) {
var t = c.steps[e];
if (t && (t.preShow && t.preShow(), t.targetScrollElement)) {
var n = $("body").find(t.targetScrollElement)[0], r = $("body").find(t.target)[0];
if (n && n) {
var o = a(r, n);
"top" === t.placement ? o -= l : o += l, o > n.clientHeight ? n.scrollTop = o : n.scrollTop = 0;
}
}
}
function a(e, t) {
return e && e !== t ? e.offsetTop + a(e.offsetParent, t) : 0;
}
var s, c = {}, l = 175, u = function() {
hopscotch.endTour();
};
return {
startTour: function(r, o) {
$("body").append('<div id="guided_tour_backdrop" class="modal-backdrop fade guided-tour-backdrop"></div>'), s = {
onTourEndCB: o,
bubblePadding: 5,
arrowWidth: 10,
onStart: e,
onEnd: t,
onClose: t,
showPrevButton: !0,
i18n: {
nextBtn: "Next >",
prevBtn: "< Back",
closeTooltip: "x"
}
}, c = {}, angular.merge(c, s, r), n(), i(0), hopscotch.startTour(c, 0);
},
cancelTour: u
};
}), angular.module("openshiftCommonUI").factory("HTMLService", [ "$sanitize", "BREAKPOINTS", function(e, t) {
return {
WINDOW_SIZE_XXS: "xxs",
WINDOW_SIZE_XS: "xs",
WINDOW_SIZE_SM: "sm",
WINDOW_SIZE_MD: "md",
WINDOW_SIZE_LG: "lg",
getBreakpoint: function() {
return window.innerWidth < t.screenXsMin ? "xxs" : window.innerWidth < t.screenSmMin ? "xs" : window.innerWidth < t.screenMdMin ? "sm" : window.innerWidth < t.screenLgMin ? "md" : "lg";
},
isWindowBelowBreakpoint: function(e) {
switch (e) {
case "xxs":
return !1;

case "xs":
return window.innerWidth < t.screenXsMin;

case "sm":
return window.innerWidth < t.screenSmMin;

case "md":
return window.innerWidth < t.screenMdMin;

case "lg":
return window.innerWidth < t.screenLgMin;

default:
return !0;
}
},
isWindowAboveBreakpoint: function(e) {
switch (e) {
case "xs":
return window.innerWidth >= t.screenXsMin;

case "sm":
return window.innerWidth >= t.screenSmMin;

case "md":
return window.innerWidth >= t.screenMdMin;

case "lg":
return window.innerWidth >= t.screenLgMin;

default:
return !0;
}
},
linkify: function(t, n, r) {
return t ? (r || (t = _.escape(t)), e(t.replace(/https?:\/\/[A-Za-z0-9._%+-]+[^\s<]*[^\s.,()\[\]{}<>"\u201d\u2019]/gm, function(e) {
return n ? '<a href="' + e + '" target="' + n + '">' + e + ' <i class="fa fa-external-link" aria-hidden="true"></i></a>' : '<a href="' + e + '">' + e + "</a>";
}))) : t;
}
};
} ]), angular.module("openshiftCommonUI").provider("NotificationsService", function() {
this.dismissDelay = 8e3, this.autoDismissTypes = [ "info", "success" ], this.$get = [ "$rootScope", function(e) {
var t = [], n = this.dismissDelay, r = this.autoDismissTypes, o = function(e, t) {
return t ? "hide/notification/" + t + "/" + e : "hide/notification/" + e;
}, i = function(n) {
n.trackByID = _.uniqueId("notification-") + Date.now(), n.skipToast = n.skipToast || !1, n.showInDrawer = n.showInDrawer || !1, n.timestamp = new Date().toISOString(), a(n) || s(n) || (t.push(n), e.$emit("NotificationsService.onNotificationAdded", n));
}, a = function(e) {
if (!e.id) return !1;
var t = o(e.id, e.namespace);
return "true" === localStorage.getItem(t);
}, s = function(e) {
return !!e.id && _.some(t, function(t) {
return !t.hidden && e.id === t.id;
});
};
return e.$on("NotificationsService.addNotification", function(e, t) {
i(t);
}), {
addNotification: i,
hideNotification: function(e) {
e && _.each(t, function(t) {
t.id === e && (t.hidden = !0);
});
},
getNotifications: function() {
return t;
},
clearNotifications: function() {
t.length = 0;
},
isNotificationPermanentlyHidden: a,
permanentlyHideNotification: function(e, t) {
var n = o(e, t);
localStorage.setItem(n, "true");
},
isAutoDismiss: function(e) {
return _.includes(r, e.type);
},
dismissDelay: n,
autoDismissTypes: r
};
} ], this.setDismissDelay = function(e) {
this.dismissDelay = e;
}, this.setAutoDismissTypes = function(e) {
this.autoDismissTypes = e;
};
}), angular.module("openshiftCommonUI").component("bindApplicationForm", {
controllerAs: "ctrl",
bindings: {
allowNoBinding: "<?",
createBinding: "=",
applicationName: "=",
formName: "=",
serviceClasses: "<",
serviceInstances: "<",
serviceToBind: "="
},
templateUrl: "src/components/binding/bindApplicationForm.html",
controller: [ "BindingService", function(e) {
function t(t) {
return e.isServiceBindable(t, n.serviceClasses);
}
var n = this;
n.$onChanges = function(e) {
(e.serviceInstances || e.serviceClasses) && (n.bindableServiceInstances = _.filter(n.serviceInstances, t));
};
} ]
}), angular.module("openshiftCommonUI").component("bindResults", {
controllerAs: "ctrl",
bindings: {
error: "<",
binding: "<",
serviceToBind: "<",
bindType: "@",
applicationToBind: "<",
showPodPresets: "<",
secretHref: "<"
},
templateUrl: "src/components/binding/bindResults.html"
}), angular.module("openshiftCommonUI").component("bindServiceForm", {
controllerAs: "ctrl",
bindings: {
serviceClass: "<",
showPodPresets: "<",
applications: "<",
formName: "=",
allowNoBinding: "<?",
projectName: "<",
bindType: "=",
appToBind: "="
},
templateUrl: "src/components/binding/bindServiceForm.html",
controller: [ "$filter", function(e) {
var t = this, n = e("humanizeKind");
t.groupByKind = function(e) {
return n(e.kind);
};
} ]
}), angular.module("openshiftCommonUI").directive("createProject", [ "$window", function(e) {
return {
restrict: "E",
scope: {
redirectAction: "&",
onCancel: "&?",
isDialog: "@"
},
templateUrl: "src/components/create-project/createProject.html",
controller: [ "$scope", "$location", "ProjectsService", "NotificationsService", "displayNameFilter", "Logger", function(t, n, r, o, i, a) {
t.submitButtonLabel || (t.submitButtonLabel = "Create"), t.isDialog = "true" === t.isDialog;
t.createProject = function() {
if (t.disableInputs = !0, t.createProjectForm.$valid) {
var e = t.displayName || t.name;
r.create(t.name, t.displayName, t.description).then(function(e) {
var r = t.redirectAction();
r ? r(encodeURIComponent(e.metadata.name)) : n.path("project/" + encodeURIComponent(e.metadata.name) + "/create"), o.addNotification({
type: "success",
message: "Project '" + i(e) + "' was successfully created."
});
}, function(n) {
t.disableInputs = !1;
var r = n.data || {};
if ("AlreadyExists" === r.reason) t.nameTaken = !0; else {
var i = r.message || "An error occurred creating project '" + e + "'.";
o.addNotification({
type: "error",
message: i
}), a.error("Project '" + e + "' could not be created.", n);
}
});
}
}, t.cancelCreateProject = function() {
if (t.onCancel) {
var n = t.onCancel();
n && n();
} else e.history.back();
}, t.$on("$destroy", function() {
o.hideNotification("create-project-error");
});
} ]
};
} ]), angular.module("openshiftCommonUI").directive("deleteProject", [ "$uibModal", "$location", "$filter", "$q", "hashSizeFilter", "APIService", "NotificationsService", "ProjectsService", "Logger", function(e, t, n, r, o, i, a, s, c) {
return {
restrict: "E",
scope: {
project: "=",
disableDelete: "=?",
typeNameToConfirm: "=?",
label: "@?",
buttonOnly: "@",
stayOnCurrentPage: "=?",
success: "=?",
redirectUrl: "@?"
},
templateUrl: function(e, t) {
return angular.isDefined(t.buttonOnly) ? "src/components/delete-project/delete-project-button.html" : "src/components/delete-project/delete-project.html";
},
replace: !0,
link: function(r, o, i) {
var l = n("displayName"), u = function() {
if (!r.stayOnCurrentPage) if (r.redirectUrl) t.url(r.redirectUrl); else if ("/" !== t.path()) {
var e = URI("/");
t.url(e);
} else r.$emit("deleteProject");
};
r.openDeleteModal = function() {
r.disableDelete || e.open({
templateUrl: "src/components/delete-project/delete-project-modal.html",
controller: "DeleteProjectModalController",
scope: r
}).result.then(function() {
var e = "Project '" + l(r.project) + "'";
s.delete(r.project).then(function() {
a.addNotification({
type: "success",
message: e + " was marked for deletion."
}), r.success && r.success(), u();
}).catch(function(t) {
a.addNotification({
type: "error",
message: e + " could not be deleted.",
details: n("getErrorDetails")(t)
}), c.error(e + " could not be deleted.", t);
});
});
};
}
};
} ]), angular.module("openshiftCommonUI").controller("DeleteProjectModalController", [ "$scope", "$uibModalInstance", function(e, t) {
e.delete = function() {
t.close("delete");
}, e.cancel = function() {
t.dismiss("cancel");
};
} ]), angular.module("openshiftCommonUI").directive("editProject", [ "$window", function(e) {
return {
restrict: "E",
scope: {
project: "=",
submitButtonLabel: "@",
redirectAction: "&",
onCancel: "&",
isDialog: "@"
},
templateUrl: "src/components/edit-project/editProject.html",
controller: [ "$scope", "$filter", "$location", "Logger", "NotificationsService", "ProjectsService", "annotationNameFilter", "displayNameFilter", function(t, n, r, o, i, a, s, c) {
t.submitButtonLabel || (t.submitButtonLabel = "Save"), t.isDialog = "true" === t.isDialog;
var l = n("annotation"), u = n("annotationName"), d = function(e) {
return {
description: l(e, "description"),
displayName: l(e, "displayName")
};
}, p = function(e, t) {
var n = angular.copy(e);
return n.metadata.annotations[u("description")] = t.description, n.metadata.annotations[u("displayName")] = t.displayName, n;
}, f = function(e) {
var t = [ s("description"), s("displayName") ];
return _.each(t, function(t) {
e.metadata.annotations[t] || delete e.metadata.annotations[t];
}), e;
};
t.editableFields = d(t.project), t.update = function() {
t.disableInputs = !0, t.editProjectForm.$valid && a.update(t.project.metadata.name, f(p(t.project, t.editableFields))).then(function(e) {
var n = t.redirectAction();
n && n(encodeURIComponent(t.project.metadata.name)), i.addNotification({
type: "success",
message: "Project '" + c(e) + "' was successfully updated."
});
}, function(e) {
t.disableInputs = !1, t.editableFields = d(t.project), i.addNotification({
type: "error",
message: "An error occurred while updating project '" + c(t.project) + "'.",
details: n("getErrorDetails")(e)
}), o.error("Project '" + c(t.project) + "' could not be updated.", e);
});
}, t.cancelEditProject = function() {
var n = t.onCancel();
n ? n() : e.history.back();
};
} ]
};
} ]), angular.module("openshiftCommonUI").component("originModalPopup", {
transclude: !0,
bindings: {
modalTitle: "@",
shown: "<",
position: "@",
referenceElement: "<?",
onClose: "<"
},
templateUrl: "src/components/origin-modal-popup/origin-modal-popup.html",
controller: [ "$scope", "HTMLService", "$element", "$window", function(e, t, n, r) {
function o() {
var e = d.referenceElement || n[0].parentNode;
if (e && t.isWindowAboveBreakpoint(t.WINDOW_SIZE_SM)) {
var o, i, a = d.position && d.position.indexOf("top") > -1, s = d.position && d.position.indexOf("left") > -1, c = e.getBoundingClientRect(), l = r.innerHeight, u = n[0].children[0], p = _.get(u, "offsetHeight", 0), f = _.get(u, "offsetWidth", 0);
c.top < p ? a = !1 : c.bottom + p > l && (a = !0), o = a ? c.top - p + "px" : c.bottom + "px", i = s ? c.left + "px" : c.right - f + "px", d.showAbove = a, d.showLeft = s, d.positionStyle = {
left: i,
top: o
};
} else d.positionStyle = {};
}
function i() {
var e = d.referenceElement ? d.referenceElement.parentNode : n[0].parentNode;
$(e).append('<div class="origin-modal-popup-backdrop modal-backdrop fade in tile-click-prevent"></div>');
}
function a() {
$(".origin-modal-popup-backdrop").remove();
}
function s() {
e.$evalAsync(o);
}
function c() {
i(), u = _.debounce(s, 50, {
maxWait: 250
}), angular.element(r).on("resize", u);
}
function l() {
a(), u && (angular.element(r).off("resize", u), u = null);
}
var u, d = this;
d.$onChanges = function(e) {
e.shown && (d.shown ? c() : l()), (e.shown || e.referenceElement) && d.shown && o();
}, d.$onDestroy = function() {
d.shown && l();
};
} ]
}), angular.module("openshiftCommonUI").directive("oscUnique", function() {
return {
restrict: "A",
scope: {
oscUnique: "=",
oscUniqueDisabled: "="
},
require: "ngModel",
link: function(e, t, n, r) {
var o = [], i = !0;
e.$watchCollection("oscUnique", function(e) {
o = _.isArray(e) ? e : _.keys(e);
});
var a = function() {
r.$setValidity("oscUnique", e.oscUniqueDisabled || i);
};
e.$watch("oscUniqueDisabled", a), r.$parsers.unshift(function(e) {
return i = !_.includes(o, e), a(), e;
});
}
};
}), angular.module("openshiftCommonUI").directive("toggle", [ "IS_IOS", function(e) {
var t = function(e) {
$("body").css("cursor", e);
}, n = _.partial(t, "pointer"), r = _.partial(t, "auto");
return e && ($(document).on("shown.bs.popover", n), $(document).on("shown.bs.tooltip", n), $(document).on("hide.bs.popover", r), $(document).on("hide.bs.tooltip", r)), {
restrict: "A",
scope: {
dynamicContent: "@?"
},
link: function(e, t, n) {
var r = {
container: n.container || "body",
placement: n.placement || "auto"
};
if (n) switch (n.toggle) {
case "popover":
(n.dynamicContent || "" === n.dynamicContent) && e.$watch("dynamicContent", function() {
$(t).popover("destroy"), setTimeout(function() {
$(t).attr("data-content", e.dynamicContent).popover(r);
}, 200);
}), $(t).popover(r), e.$on("$destroy", function() {
$(t).popover("destroy");
});
break;

case "tooltip":
(n.dynamicContent || "" === n.dynamicContent) && e.$watch("dynamicContent", function() {
$(t).tooltip("destroy"), setTimeout(function() {
$(t).attr("title", e.dynamicContent).tooltip(r);
}, 200);
}), $(t).tooltip(r), e.$on("$destroy", function() {
$(t).tooltip("destroy");
});
break;

case "dropdown":
"dropdown" === n.hover && ($(t).dropdownHover({
delay: 200
}), $(t).dropdown());
}
}
};
} ]), angular.module("openshiftCommonUI").directive("takeFocus", [ "$timeout", function(e) {
return {
restrict: "A",
link: function(t, n) {
e(function() {
$(n).focus();
}, 300);
}
};
} ]), angular.module("openshiftCommonUI").directive("tileClick", function() {
return {
restrict: "AC",
link: function(e, t) {
$(t).click(function(e) {
var n = $(e.target);
n && (n.closest("a", t).length || n.closest("button", t).length) || n.closest(".tile-click-prevent", t).length || angular.element($("a.tile-target", t))[0].click();
});
}
};
}), angular.module("openshiftCommonUI").directive("toastNotifications", [ "NotificationsService", "$rootScope", "$timeout", function(e, t, n) {
return {
restrict: "E",
scope: {},
templateUrl: "src/components/toast-notifications/toast-notifications.html",
link: function(r) {
r.notifications = [];
var o = function(e) {
return e.hidden && !e.isHover;
}, i = function(e) {
e.isHover = !1, e.hidden = !0;
}, a = function() {
r.notifications = _.reject(r.notifications, o);
};
r.close = function(e) {
i(e), _.isFunction(e.onClose) && e.onClose();
}, r.onClick = function(e, t) {
_.isFunction(t.onClick) && t.onClick() && i(e);
}, r.setHover = function(e, t) {
o(e) || (e.isHover = t);
};
var s = t.$on("NotificationsService.onNotificationAdded", function(t, o) {
o.skipToast || r.$evalAsync(function() {
r.notifications.push(o), e.isAutoDismiss(o) && n(function() {
o.hidden = !0;
}, e.dismissDelay), a();
});
});
r.$on("$destroy", function() {
s && (s(), s = null);
});
}
};
} ]), angular.module("openshiftCommonUI").directive("truncateLongText", [ "truncateFilter", function(e) {
return {
restrict: "E",
scope: {
content: "=",
limit: "=",
newlineLimit: "=",
useWordBoundary: "=",
expandable: "=",
hideCollapse: "=",
keywords: "=highlightKeywords",
linkify: "=?"
},
templateUrl: "src/components/truncate-long-text/truncateLongText.html",
link: function(t) {
t.toggles = {
expanded: !1
}, t.$watch("content", function(n) {
n ? (t.truncatedContent = e(n, t.limit, t.useWordBoundary, t.newlineLimit), t.truncated = t.truncatedContent.length !== n.length) : (t.truncatedContent = null, t.truncated = !1);
});
}
};
} ]);